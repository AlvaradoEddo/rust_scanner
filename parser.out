Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARROW
    AS
    ASYNC
    AWAIT
    BREAK
    B_FALSE
    B_TRUE
    CONST
    CONTIN
    CRATE
    DOLLAR
    DOTDOTDOT
    DYN
    ENUM
    ERRORPROP
    EXTERN
    F32
    IMPL
    LESSEQ
    LOOP
    MATCH
    MAYOR
    MAYORIGUAL
    MOD
    MOVE
    NOT
    NUMBER
    OR
    PRINT
    REF
    RETURN
    SELF
    SELFLOWERCASE
    STATIC
    SUPER
    TRAIT
    TYPE
    UNSAFE
    USE
    WHERE

Grammar

Rule 0     S' -> rust
Rule 1     rust -> asignacion
Rule 2     rust -> prints
Rule 3     rust -> hashset
Rule 4     rust -> hashfunc
Rule 5     rust -> conditional
Rule 6     rust -> conditional_asigned
Rule 7     rust -> for_loop
Rule 8     rust -> struct_s
Rule 9     rust -> while_loop
Rule 10    rust -> empty_vector
Rule 11    rust -> vector_methods
Rule 12    rust -> data_vector
Rule 13    rust -> slice_get
Rule 14    rust -> slice_contains
Rule 15    rust -> read_data
Rule 16    rust -> function
Rule 17    rust -> empty_function
Rule 18    asignacion -> declarador ASIGNAR expresion ENDLINE
Rule 19    asignacion -> other_operators ENDLINE
Rule 20    other_operators -> VARIABLE oper_asig expresion
Rule 21    declarador -> VARIABLE
Rule 22    declarador -> let_asig
Rule 23    let_asig -> LET var_tipo
Rule 24    let_asig -> LET MUT var_tipo
Rule 25    var_tipo -> VARIABLE
Rule 26    var_tipo -> VARIABLE ASIGNATION_TYPE tipos
Rule 27    oper_asig -> ASIGNAR
Rule 28    oper_asig -> PLUSEQ
Rule 29    oper_asig -> MINUSEQ
Rule 30    oper_asig -> STAREQ
Rule 31    oper_asig -> SLASHEQ
Rule 32    prints -> PRINTS LPAREN print_expresion RPAREN ENDLINE
Rule 33    print_expresion -> STRING
Rule 34    print_expresion -> STRING COMMA print_args
Rule 35    print_args -> print_datos COMMA print_args
Rule 36    print_args -> print_datos
Rule 37    print_datos -> expresion
Rule 38    hashset -> LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
Rule 39    hashfunc -> hashset_insert
Rule 40    hashfunc -> hashset_union
Rule 41    hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
Rule 42    hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
Rule 43    conditional_asigned -> declarador ASIGNAR conditional ENDLINE
Rule 44    conditional -> if_type validations LLAVEIZ rust LLAVEDER
Rule 45    if_type -> IF
Rule 46    if_type -> ELSE IF
Rule 47    if_type -> ELSE
Rule 48    validations -> comparison
Rule 49    validations -> comparison ANDAND validations
Rule 50    validations -> comparison OROR validations
Rule 51    comparison -> VARIABLE signo_comp VARIABLE
Rule 52    comparison -> VARIABLE signo_comp U8
Rule 53    comparison -> U8 signo_comp VARIABLE
Rule 54    signo_comp -> GREATER
Rule 55    signo_comp -> LESST
Rule 56    signo_comp -> GREATEQ
Rule 57    signo_comp -> EQUAL
Rule 58    signo_comp -> DIFFERENT
Rule 59    f_comparacion -> rango
Rule 60    f_comparacion -> VARIABLE
Rule 61    for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
Rule 62    struct_s -> STRUCT sent_stru
Rule 63    argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos
Rule 64    argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
Rule 65    argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
Rule 66    argumentos_tipo -> tipos
Rule 67    argumentos_tipo -> tipos COMMA argumentos_tipo
Rule 68    sent_stru -> UNIT ENDLINE
Rule 69    sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN ENDLINE
Rule 70    sent_stru -> VARIABLE LLAVEIZ argumentos_juntos LLAVEDER
Rule 71    op_mat -> art_exp
Rule 72    op_mat -> VARIABLE signo_arit art_exp
Rule 73    op_mat -> U8 signo_arit art_exp
Rule 74    art_exp -> VARIABLE signo_arit VARIABLE
Rule 75    art_exp -> U8 signo_arit VARIABLE
Rule 76    art_exp -> VARIABLE signo_arit U8
Rule 77    art_exp -> U8 signo_arit U8
Rule 78    signo_arit -> MAS
Rule 79    signo_arit -> MENOS
Rule 80    signo_arit -> MULT
Rule 81    signo_arit -> DIVISION
Rule 82    signo_arit -> MODULO
Rule 83    rango -> U8 DOT DOT U8
Rule 84    slice_exp -> AND empty VARIABLE empty BRACKETL rango BRACKETR
Rule 85    slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
Rule 86    valor_get -> rango
Rule 87    valor_get -> U8
Rule 88    slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
Rule 89    empty -> <empty>
Rule 90    while_loop -> WHILE validations LLAVEIZ rust LLAVEDER
Rule 91    read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
Rule 92    reference -> AND empty MUT VARIABLE
Rule 93    function -> FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
Rule 94    empty_function -> FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
Rule 95    arguments -> VARIABLE ASIGNATION_TYPE tipos
Rule 96    arguments -> VARIABLE ASIGNATION_TYPE tipos COMMA arguments
Rule 97    empty_vector -> declare_vector VECT types_vector empty_vec
Rule 98    data_vector -> declare_vector VECT types_vector vector_content
Rule 99    data_vector -> declare_vector vector_content
Rule 100   data_vector -> declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE
Rule 101   vector_content -> VECTMACRO LLAVEIZ vector_elements LLAVEDER ENDLINE
Rule 102   vector_content -> VECT empty PATHSEP empty FROM LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE
Rule 103   vector_elements -> element
Rule 104   vector_elements -> element COMMA vector_elements
Rule 105   element -> expresion
Rule 106   element_type -> U8 NUMDATATYPES
Rule 107   types_vector -> LESST DATATYPES GREATER
Rule 108   types_vector -> LESST NUMDATATYPES GREATER
Rule 109   declare_vector -> LET MUT VARIABLE ASIGNATION_TYPE
Rule 110   declare_vector -> LET VARIABLE ASIGNATION_TYPE
Rule 111   empty_vec -> ASIGNAR VECT PATHSEP NEWFUNC ENDLINE
Rule 112   empty_vec -> ASIGNAR VECTMACRO BRACKETL BRACKETR ENDLINE
Rule 113   empty_vec -> ASIGNAR VECT PATHSEP FROM LPAREN RPAREN ENDLINE
Rule 114   vector_methods -> VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
Rule 115   vector_methods -> VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
Rule 116   tipos -> DATATYPES
Rule 117   tipos -> NUMDATATYPES
Rule 118   expresion -> STRING
Rule 119   expresion -> U8
Rule 120   expresion -> op_mat
Rule 121   expresion -> slice_exp

Terminals, with rules where they appear

AND                  : 42 84 88 92
ANDAND               : 49
ARROW                : 
AS                   : 
ASIGNAR              : 18 27 38 43 100 111 112 113
ASIGNATION_TYPE      : 26 63 64 65 95 96 109 110
ASYNC                : 
AWAIT                : 
BRACKETL             : 84 112
BRACKETR             : 84 112
BREAK                : 
B_FALSE              : 
B_TRUE               : 
COMMA                : 34 35 64 65 67 96 100 104
CONST                : 
CONTAINS_SLICE       : 88
CONTIN               : 
CRATE                : 
DATATYPES            : 107 116
DIFFERENT            : 58
DIVISION             : 81
DOLLAR               : 
DOT                  : 41 42 83 83 85 88 91 114 115
DOTDOTDOT            : 
DYN                  : 
ELSE                 : 46 47
ENDLINE              : 18 19 32 38 41 42 43 68 69 91 100 101 102 111 112 113
ENUM                 : 
EQUAL                : 57
ERRORPROP            : 
EXTERN               : 
F32                  : 
FOR                  : 61
FROM                 : 102 113
FUNCTION             : 93 94
GET_SLICE            : 85
GREATEQ              : 56
GREATER              : 54 107 108
HASHSET              : 38
IF                   : 45 46
IMPL                 : 
IN                   : 61
INSERT_HASH          : 41
IO                   : 91
LESSEQ               : 
LESST                : 55 107 108
LET                  : 23 24 38 109 110
LLAVEDER             : 44 61 70 90 93 94 100 101 102
LLAVEIZ              : 44 61 70 90 93 94 100 101 102
LOOP                 : 
LPAREN               : 32 41 42 69 85 88 91 91 93 94 102 113 114 115
MAS                  : 78
MATCH                : 
MAYOR                : 
MAYORIGUAL           : 
MENOS                : 79
MINUSEQ              : 29
MOD                  : 
MODULO               : 82
MOVE                 : 
MULT                 : 80
MUT                  : 24 38 92 109
NEWFUNC              : 38 111
NOT                  : 
NUMBER               : 
NUMDATATYPES         : 106 108 117
OR                   : 
OROR                 : 50
PATHSEP              : 38 91 102 111 113
PLUSEQ               : 28
POP_VEC              : 115
PRINT                : 
PRINTS               : 32
PUB                  : 65
PUSH_VEC             : 114
READ                 : 91
REF                  : 
RETURN               : 
RPAREN               : 32 41 42 69 85 88 91 91 93 94 102 113 114 115
SELF                 : 
SELFLOWERCASE        : 
SLASHEQ              : 31
STAREQ               : 30
STATIC               : 
STDIN                : 91
STRING               : 33 34 118
STRUCT               : 62
SUPER                : 
TRAIT                : 
TUPLE                : 69
TYPE                 : 
U8                   : 52 53 73 75 76 77 77 83 83 87 88 106 119
UNION_HASH           : 42
UNIT                 : 68
UNSAFE               : 
USE                  : 
VARIABLE             : 20 21 25 26 38 41 42 42 51 51 52 53 60 61 63 64 65 70 72 74 74 75 76 84 85 88 92 93 94 95 96 109 110 114 115
VECT                 : 97 98 102 111 113
VECTMACRO            : 100 101 112
WHERE                : 
WHILE                : 90
error                : 

Nonterminals, with rules where they appear

argumentos_juntos    : 64 65 70
argumentos_tipo      : 67 69
arguments            : 93 96
art_exp              : 71 72 73
asignacion           : 1
comparison           : 48 49 50
conditional          : 5 43
conditional_asigned  : 6
data_vector          : 12
declarador           : 18 43
declare_vector       : 97 98 99 100
element              : 103 104
element_type         : 100
empty                : 84 84 85 85 85 88 88 88 91 91 91 91 92 102 102 114 114 115 115
empty_function       : 17
empty_vec            : 97
empty_vector         : 10
expresion            : 18 20 37 41 105 114
f_comparacion        : 61
for_loop             : 7
function             : 16
hashfunc             : 4
hashset              : 3
hashset_insert       : 39
hashset_union        : 40
if_type              : 44
let_asig             : 22
op_mat               : 120
oper_asig            : 20
other_operators      : 19
print_args           : 34 35
print_datos          : 35 36
print_expresion      : 32
prints               : 2
rango                : 59 84 86
read_data            : 15
reference            : 91
rust                 : 44 61 90 93 94 0
sent_stru            : 62
signo_arit           : 72 73 74 75 76 77
signo_comp           : 51 52 53
slice_contains       : 14
slice_exp            : 121
slice_get            : 13
struct_s             : 8
tipos                : 26 63 64 65 66 67 95 96
types_vector         : 97 98
validations          : 44 49 50 90
valor_get            : 85
var_tipo             : 23 24
vector_content       : 98 99
vector_elements      : 100 101 102 104
vector_methods       : 11
while_loop           : 9

Parsing method: LALR

state 0

    (0) S' -> . rust
    (1) rust -> . asignacion
    (2) rust -> . prints
    (3) rust -> . hashset
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . while_loop
    (10) rust -> . empty_vector
    (11) rust -> . vector_methods
    (12) rust -> . data_vector
    (13) rust -> . slice_get
    (14) rust -> . slice_contains
    (15) rust -> . read_data
    (16) rust -> . function
    (17) rust -> . empty_function
    (18) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (19) asignacion -> . other_operators ENDLINE
    (32) prints -> . PRINTS LPAREN print_expresion RPAREN ENDLINE
    (38) hashset -> . LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (39) hashfunc -> . hashset_insert
    (40) hashfunc -> . hashset_union
    (44) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (43) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (61) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (62) struct_s -> . STRUCT sent_stru
    (90) while_loop -> . WHILE validations LLAVEIZ rust LLAVEDER
    (97) empty_vector -> . declare_vector VECT types_vector empty_vec
    (114) vector_methods -> . VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (115) vector_methods -> . VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
    (98) data_vector -> . declare_vector VECT types_vector vector_content
    (99) data_vector -> . declare_vector vector_content
    (100) data_vector -> . declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE
    (85) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (88) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (91) read_data -> . IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (93) function -> . FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (94) empty_function -> . FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
    (21) declarador -> . VARIABLE
    (22) declarador -> . let_asig
    (20) other_operators -> . VARIABLE oper_asig expresion
    (41) hashset_insert -> . VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (42) hashset_union -> . VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
    (45) if_type -> . IF
    (46) if_type -> . ELSE IF
    (47) if_type -> . ELSE
    (109) declare_vector -> . LET MUT VARIABLE ASIGNATION_TYPE
    (110) declare_vector -> . LET VARIABLE ASIGNATION_TYPE
    (23) let_asig -> . LET var_tipo
    (24) let_asig -> . LET MUT var_tipo

    PRINTS          shift and go to state 21
    LET             shift and go to state 22
    FOR             shift and go to state 27
    STRUCT          shift and go to state 28
    WHILE           shift and go to state 29
    VARIABLE        shift and go to state 23
    IO              shift and go to state 31
    FUNCTION        shift and go to state 32
    IF              shift and go to state 34
    ELSE            shift and go to state 35

    rust                           shift and go to state 1
    asignacion                     shift and go to state 2
    prints                         shift and go to state 3
    hashset                        shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    while_loop                     shift and go to state 10
    empty_vector                   shift and go to state 11
    vector_methods                 shift and go to state 12
    data_vector                    shift and go to state 13
    slice_get                      shift and go to state 14
    slice_contains                 shift and go to state 15
    read_data                      shift and go to state 16
    function                       shift and go to state 17
    empty_function                 shift and go to state 18
    declarador                     shift and go to state 19
    other_operators                shift and go to state 20
    hashset_insert                 shift and go to state 24
    hashset_union                  shift and go to state 25
    if_type                        shift and go to state 26
    declare_vector                 shift and go to state 30
    let_asig                       shift and go to state 33

state 1

    (0) S' -> rust .



state 2

    (1) rust -> asignacion .

    $end            reduce using rule 1 (rust -> asignacion .)
    LLAVEDER        reduce using rule 1 (rust -> asignacion .)


state 3

    (2) rust -> prints .

    $end            reduce using rule 2 (rust -> prints .)
    LLAVEDER        reduce using rule 2 (rust -> prints .)


state 4

    (3) rust -> hashset .

    $end            reduce using rule 3 (rust -> hashset .)
    LLAVEDER        reduce using rule 3 (rust -> hashset .)


state 5

    (4) rust -> hashfunc .

    $end            reduce using rule 4 (rust -> hashfunc .)
    LLAVEDER        reduce using rule 4 (rust -> hashfunc .)


state 6

    (5) rust -> conditional .

    $end            reduce using rule 5 (rust -> conditional .)
    LLAVEDER        reduce using rule 5 (rust -> conditional .)


state 7

    (6) rust -> conditional_asigned .

    $end            reduce using rule 6 (rust -> conditional_asigned .)
    LLAVEDER        reduce using rule 6 (rust -> conditional_asigned .)


state 8

    (7) rust -> for_loop .

    $end            reduce using rule 7 (rust -> for_loop .)
    LLAVEDER        reduce using rule 7 (rust -> for_loop .)


state 9

    (8) rust -> struct_s .

    $end            reduce using rule 8 (rust -> struct_s .)
    LLAVEDER        reduce using rule 8 (rust -> struct_s .)


state 10

    (9) rust -> while_loop .

    $end            reduce using rule 9 (rust -> while_loop .)
    LLAVEDER        reduce using rule 9 (rust -> while_loop .)


state 11

    (10) rust -> empty_vector .

    $end            reduce using rule 10 (rust -> empty_vector .)
    LLAVEDER        reduce using rule 10 (rust -> empty_vector .)


state 12

    (11) rust -> vector_methods .

    $end            reduce using rule 11 (rust -> vector_methods .)
    LLAVEDER        reduce using rule 11 (rust -> vector_methods .)


state 13

    (12) rust -> data_vector .

    $end            reduce using rule 12 (rust -> data_vector .)
    LLAVEDER        reduce using rule 12 (rust -> data_vector .)


state 14

    (13) rust -> slice_get .

    $end            reduce using rule 13 (rust -> slice_get .)
    LLAVEDER        reduce using rule 13 (rust -> slice_get .)


state 15

    (14) rust -> slice_contains .

    $end            reduce using rule 14 (rust -> slice_contains .)
    LLAVEDER        reduce using rule 14 (rust -> slice_contains .)


state 16

    (15) rust -> read_data .

    $end            reduce using rule 15 (rust -> read_data .)
    LLAVEDER        reduce using rule 15 (rust -> read_data .)


state 17

    (16) rust -> function .

    $end            reduce using rule 16 (rust -> function .)
    LLAVEDER        reduce using rule 16 (rust -> function .)


state 18

    (17) rust -> empty_function .

    $end            reduce using rule 17 (rust -> empty_function .)
    LLAVEDER        reduce using rule 17 (rust -> empty_function .)


state 19

    (18) asignacion -> declarador . ASIGNAR expresion ENDLINE
    (43) conditional_asigned -> declarador . ASIGNAR conditional ENDLINE

    ASIGNAR         shift and go to state 36


state 20

    (19) asignacion -> other_operators . ENDLINE

    ENDLINE         shift and go to state 37


state 21

    (32) prints -> PRINTS . LPAREN print_expresion RPAREN ENDLINE

    LPAREN          shift and go to state 38


state 22

    (38) hashset -> LET . MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (109) declare_vector -> LET . MUT VARIABLE ASIGNATION_TYPE
    (110) declare_vector -> LET . VARIABLE ASIGNATION_TYPE
    (23) let_asig -> LET . var_tipo
    (24) let_asig -> LET . MUT var_tipo
    (25) var_tipo -> . VARIABLE
    (26) var_tipo -> . VARIABLE ASIGNATION_TYPE tipos

    MUT             shift and go to state 39
    VARIABLE        shift and go to state 40

    var_tipo                       shift and go to state 41

state 23

    (114) vector_methods -> VARIABLE . empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (115) vector_methods -> VARIABLE . empty DOT empty POP_VEC LPAREN RPAREN
    (85) slice_get -> VARIABLE . empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (88) slice_contains -> VARIABLE . empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (21) declarador -> VARIABLE .
    (20) other_operators -> VARIABLE . oper_asig expresion
    (41) hashset_insert -> VARIABLE . DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (42) hashset_union -> VARIABLE . DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
    (89) empty -> .
    (27) oper_asig -> . ASIGNAR
    (28) oper_asig -> . PLUSEQ
    (29) oper_asig -> . MINUSEQ
    (30) oper_asig -> . STAREQ
    (31) oper_asig -> . SLASHEQ

  ! shift/reduce conflict for DOT resolved as shift
  ! shift/reduce conflict for ASIGNAR resolved as shift
    DOT             shift and go to state 43
    ASIGNAR         shift and go to state 45
    PLUSEQ          shift and go to state 46
    MINUSEQ         shift and go to state 47
    STAREQ          shift and go to state 48
    SLASHEQ         shift and go to state 49

  ! ASIGNAR         [ reduce using rule 21 (declarador -> VARIABLE .) ]
  ! DOT             [ reduce using rule 89 (empty -> .) ]

    empty                          shift and go to state 42
    oper_asig                      shift and go to state 44

state 24

    (39) hashfunc -> hashset_insert .

    $end            reduce using rule 39 (hashfunc -> hashset_insert .)
    LLAVEDER        reduce using rule 39 (hashfunc -> hashset_insert .)


state 25

    (40) hashfunc -> hashset_union .

    $end            reduce using rule 40 (hashfunc -> hashset_union .)
    LLAVEDER        reduce using rule 40 (hashfunc -> hashset_union .)


state 26

    (44) conditional -> if_type . validations LLAVEIZ rust LLAVEDER
    (48) validations -> . comparison
    (49) validations -> . comparison ANDAND validations
    (50) validations -> . comparison OROR validations
    (51) comparison -> . VARIABLE signo_comp VARIABLE
    (52) comparison -> . VARIABLE signo_comp U8
    (53) comparison -> . U8 signo_comp VARIABLE

    VARIABLE        shift and go to state 52
    U8              shift and go to state 53

    validations                    shift and go to state 50
    comparison                     shift and go to state 51

state 27

    (61) for_loop -> FOR . VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER

    VARIABLE        shift and go to state 54


state 28

    (62) struct_s -> STRUCT . sent_stru
    (68) sent_stru -> . UNIT ENDLINE
    (69) sent_stru -> . TUPLE LPAREN argumentos_tipo RPAREN ENDLINE
    (70) sent_stru -> . VARIABLE LLAVEIZ argumentos_juntos LLAVEDER

    UNIT            shift and go to state 56
    TUPLE           shift and go to state 57
    VARIABLE        shift and go to state 58

    sent_stru                      shift and go to state 55

state 29

    (90) while_loop -> WHILE . validations LLAVEIZ rust LLAVEDER
    (48) validations -> . comparison
    (49) validations -> . comparison ANDAND validations
    (50) validations -> . comparison OROR validations
    (51) comparison -> . VARIABLE signo_comp VARIABLE
    (52) comparison -> . VARIABLE signo_comp U8
    (53) comparison -> . U8 signo_comp VARIABLE

    VARIABLE        shift and go to state 52
    U8              shift and go to state 53

    validations                    shift and go to state 59
    comparison                     shift and go to state 51

state 30

    (97) empty_vector -> declare_vector . VECT types_vector empty_vec
    (98) data_vector -> declare_vector . VECT types_vector vector_content
    (99) data_vector -> declare_vector . vector_content
    (100) data_vector -> declare_vector . ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE
    (101) vector_content -> . VECTMACRO LLAVEIZ vector_elements LLAVEDER ENDLINE
    (102) vector_content -> . VECT empty PATHSEP empty FROM LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE

    VECT            shift and go to state 60
    ASIGNAR         shift and go to state 62
    VECTMACRO       shift and go to state 63

    vector_content                 shift and go to state 61

state 31

    (91) read_data -> IO . empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (89) empty -> .

    PATHSEP         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 64

state 32

    (93) function -> FUNCTION . VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (94) empty_function -> FUNCTION . VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER

    VARIABLE        shift and go to state 65


state 33

    (22) declarador -> let_asig .

    ASIGNAR         reduce using rule 22 (declarador -> let_asig .)


state 34

    (45) if_type -> IF .

    VARIABLE        reduce using rule 45 (if_type -> IF .)
    U8              reduce using rule 45 (if_type -> IF .)


state 35

    (46) if_type -> ELSE . IF
    (47) if_type -> ELSE .

    IF              shift and go to state 66
    VARIABLE        reduce using rule 47 (if_type -> ELSE .)
    U8              reduce using rule 47 (if_type -> ELSE .)


state 36

    (18) asignacion -> declarador ASIGNAR . expresion ENDLINE
    (43) conditional_asigned -> declarador ASIGNAR . conditional ENDLINE
    (118) expresion -> . STRING
    (119) expresion -> . U8
    (120) expresion -> . op_mat
    (121) expresion -> . slice_exp
    (44) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (71) op_mat -> . art_exp
    (72) op_mat -> . VARIABLE signo_arit art_exp
    (73) op_mat -> . U8 signo_arit art_exp
    (84) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (45) if_type -> . IF
    (46) if_type -> . ELSE IF
    (47) if_type -> . ELSE
    (74) art_exp -> . VARIABLE signo_arit VARIABLE
    (75) art_exp -> . U8 signo_arit VARIABLE
    (76) art_exp -> . VARIABLE signo_arit U8
    (77) art_exp -> . U8 signo_arit U8

    STRING          shift and go to state 69
    U8              shift and go to state 70
    VARIABLE        shift and go to state 74
    AND             shift and go to state 75
    IF              shift and go to state 34
    ELSE            shift and go to state 35

    expresion                      shift and go to state 67
    conditional                    shift and go to state 68
    op_mat                         shift and go to state 71
    slice_exp                      shift and go to state 72
    if_type                        shift and go to state 26
    art_exp                        shift and go to state 73

state 37

    (19) asignacion -> other_operators ENDLINE .

    $end            reduce using rule 19 (asignacion -> other_operators ENDLINE .)
    LLAVEDER        reduce using rule 19 (asignacion -> other_operators ENDLINE .)


state 38

    (32) prints -> PRINTS LPAREN . print_expresion RPAREN ENDLINE
    (33) print_expresion -> . STRING
    (34) print_expresion -> . STRING COMMA print_args

    STRING          shift and go to state 77

    print_expresion                shift and go to state 76

state 39

    (38) hashset -> LET MUT . VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (109) declare_vector -> LET MUT . VARIABLE ASIGNATION_TYPE
    (24) let_asig -> LET MUT . var_tipo
    (25) var_tipo -> . VARIABLE
    (26) var_tipo -> . VARIABLE ASIGNATION_TYPE tipos

    VARIABLE        shift and go to state 78

    var_tipo                       shift and go to state 79

state 40

    (110) declare_vector -> LET VARIABLE . ASIGNATION_TYPE
    (25) var_tipo -> VARIABLE .
    (26) var_tipo -> VARIABLE . ASIGNATION_TYPE tipos

    ASIGNATION_TYPE shift and go to state 80
    ASIGNAR         reduce using rule 25 (var_tipo -> VARIABLE .)


state 41

    (23) let_asig -> LET var_tipo .

    ASIGNAR         reduce using rule 23 (let_asig -> LET var_tipo .)


state 42

    (114) vector_methods -> VARIABLE empty . DOT empty PUSH_VEC LPAREN expresion RPAREN
    (115) vector_methods -> VARIABLE empty . DOT empty POP_VEC LPAREN RPAREN
    (85) slice_get -> VARIABLE empty . DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (88) slice_contains -> VARIABLE empty . DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN

    DOT             shift and go to state 81


state 43

    (41) hashset_insert -> VARIABLE DOT . INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (42) hashset_union -> VARIABLE DOT . UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE

    INSERT_HASH     shift and go to state 82
    UNION_HASH      shift and go to state 83


state 44

    (20) other_operators -> VARIABLE oper_asig . expresion
    (118) expresion -> . STRING
    (119) expresion -> . U8
    (120) expresion -> . op_mat
    (121) expresion -> . slice_exp
    (71) op_mat -> . art_exp
    (72) op_mat -> . VARIABLE signo_arit art_exp
    (73) op_mat -> . U8 signo_arit art_exp
    (84) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (74) art_exp -> . VARIABLE signo_arit VARIABLE
    (75) art_exp -> . U8 signo_arit VARIABLE
    (76) art_exp -> . VARIABLE signo_arit U8
    (77) art_exp -> . U8 signo_arit U8

    STRING          shift and go to state 69
    U8              shift and go to state 70
    VARIABLE        shift and go to state 74
    AND             shift and go to state 75

    expresion                      shift and go to state 84
    op_mat                         shift and go to state 71
    slice_exp                      shift and go to state 72
    art_exp                        shift and go to state 73

state 45

    (27) oper_asig -> ASIGNAR .

    STRING          reduce using rule 27 (oper_asig -> ASIGNAR .)
    U8              reduce using rule 27 (oper_asig -> ASIGNAR .)
    VARIABLE        reduce using rule 27 (oper_asig -> ASIGNAR .)
    AND             reduce using rule 27 (oper_asig -> ASIGNAR .)


state 46

    (28) oper_asig -> PLUSEQ .

    STRING          reduce using rule 28 (oper_asig -> PLUSEQ .)
    U8              reduce using rule 28 (oper_asig -> PLUSEQ .)
    VARIABLE        reduce using rule 28 (oper_asig -> PLUSEQ .)
    AND             reduce using rule 28 (oper_asig -> PLUSEQ .)


state 47

    (29) oper_asig -> MINUSEQ .

    STRING          reduce using rule 29 (oper_asig -> MINUSEQ .)
    U8              reduce using rule 29 (oper_asig -> MINUSEQ .)
    VARIABLE        reduce using rule 29 (oper_asig -> MINUSEQ .)
    AND             reduce using rule 29 (oper_asig -> MINUSEQ .)


state 48

    (30) oper_asig -> STAREQ .

    STRING          reduce using rule 30 (oper_asig -> STAREQ .)
    U8              reduce using rule 30 (oper_asig -> STAREQ .)
    VARIABLE        reduce using rule 30 (oper_asig -> STAREQ .)
    AND             reduce using rule 30 (oper_asig -> STAREQ .)


state 49

    (31) oper_asig -> SLASHEQ .

    STRING          reduce using rule 31 (oper_asig -> SLASHEQ .)
    U8              reduce using rule 31 (oper_asig -> SLASHEQ .)
    VARIABLE        reduce using rule 31 (oper_asig -> SLASHEQ .)
    AND             reduce using rule 31 (oper_asig -> SLASHEQ .)


state 50

    (44) conditional -> if_type validations . LLAVEIZ rust LLAVEDER

    LLAVEIZ         shift and go to state 85


state 51

    (48) validations -> comparison .
    (49) validations -> comparison . ANDAND validations
    (50) validations -> comparison . OROR validations

    LLAVEIZ         reduce using rule 48 (validations -> comparison .)
    ANDAND          shift and go to state 86
    OROR            shift and go to state 87


state 52

    (51) comparison -> VARIABLE . signo_comp VARIABLE
    (52) comparison -> VARIABLE . signo_comp U8
    (54) signo_comp -> . GREATER
    (55) signo_comp -> . LESST
    (56) signo_comp -> . GREATEQ
    (57) signo_comp -> . EQUAL
    (58) signo_comp -> . DIFFERENT

    GREATER         shift and go to state 89
    LESST           shift and go to state 90
    GREATEQ         shift and go to state 91
    EQUAL           shift and go to state 92
    DIFFERENT       shift and go to state 93

    signo_comp                     shift and go to state 88

state 53

    (53) comparison -> U8 . signo_comp VARIABLE
    (54) signo_comp -> . GREATER
    (55) signo_comp -> . LESST
    (56) signo_comp -> . GREATEQ
    (57) signo_comp -> . EQUAL
    (58) signo_comp -> . DIFFERENT

    GREATER         shift and go to state 89
    LESST           shift and go to state 90
    GREATEQ         shift and go to state 91
    EQUAL           shift and go to state 92
    DIFFERENT       shift and go to state 93

    signo_comp                     shift and go to state 94

state 54

    (61) for_loop -> FOR VARIABLE . IN f_comparacion LLAVEIZ rust LLAVEDER

    IN              shift and go to state 95


state 55

    (62) struct_s -> STRUCT sent_stru .

    $end            reduce using rule 62 (struct_s -> STRUCT sent_stru .)
    LLAVEDER        reduce using rule 62 (struct_s -> STRUCT sent_stru .)


state 56

    (68) sent_stru -> UNIT . ENDLINE

    ENDLINE         shift and go to state 96


state 57

    (69) sent_stru -> TUPLE . LPAREN argumentos_tipo RPAREN ENDLINE

    LPAREN          shift and go to state 97


state 58

    (70) sent_stru -> VARIABLE . LLAVEIZ argumentos_juntos LLAVEDER

    LLAVEIZ         shift and go to state 98


state 59

    (90) while_loop -> WHILE validations . LLAVEIZ rust LLAVEDER

    LLAVEIZ         shift and go to state 99


state 60

    (97) empty_vector -> declare_vector VECT . types_vector empty_vec
    (98) data_vector -> declare_vector VECT . types_vector vector_content
    (102) vector_content -> VECT . empty PATHSEP empty FROM LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE
    (107) types_vector -> . LESST DATATYPES GREATER
    (108) types_vector -> . LESST NUMDATATYPES GREATER
    (89) empty -> .

    LESST           shift and go to state 102
    PATHSEP         reduce using rule 89 (empty -> .)

    types_vector                   shift and go to state 100
    empty                          shift and go to state 101

state 61

    (99) data_vector -> declare_vector vector_content .

    $end            reduce using rule 99 (data_vector -> declare_vector vector_content .)
    LLAVEDER        reduce using rule 99 (data_vector -> declare_vector vector_content .)


state 62

    (100) data_vector -> declare_vector ASIGNAR . VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE

    VECTMACRO       shift and go to state 103


state 63

    (101) vector_content -> VECTMACRO . LLAVEIZ vector_elements LLAVEDER ENDLINE

    LLAVEIZ         shift and go to state 104


state 64

    (91) read_data -> IO empty . PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE

    PATHSEP         shift and go to state 105


state 65

    (93) function -> FUNCTION VARIABLE . LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (94) empty_function -> FUNCTION VARIABLE . LPAREN RPAREN LLAVEIZ rust LLAVEDER

    LPAREN          shift and go to state 106


state 66

    (46) if_type -> ELSE IF .

    VARIABLE        reduce using rule 46 (if_type -> ELSE IF .)
    U8              reduce using rule 46 (if_type -> ELSE IF .)


state 67

    (18) asignacion -> declarador ASIGNAR expresion . ENDLINE

    ENDLINE         shift and go to state 107


state 68

    (43) conditional_asigned -> declarador ASIGNAR conditional . ENDLINE

    ENDLINE         shift and go to state 108


state 69

    (118) expresion -> STRING .

    ENDLINE         reduce using rule 118 (expresion -> STRING .)
    COMMA           reduce using rule 118 (expresion -> STRING .)
    LLAVEDER        reduce using rule 118 (expresion -> STRING .)
    RPAREN          reduce using rule 118 (expresion -> STRING .)


state 70

    (119) expresion -> U8 .
    (73) op_mat -> U8 . signo_arit art_exp
    (75) art_exp -> U8 . signo_arit VARIABLE
    (77) art_exp -> U8 . signo_arit U8
    (78) signo_arit -> . MAS
    (79) signo_arit -> . MENOS
    (80) signo_arit -> . MULT
    (81) signo_arit -> . DIVISION
    (82) signo_arit -> . MODULO

    ENDLINE         reduce using rule 119 (expresion -> U8 .)
    COMMA           reduce using rule 119 (expresion -> U8 .)
    LLAVEDER        reduce using rule 119 (expresion -> U8 .)
    RPAREN          reduce using rule 119 (expresion -> U8 .)
    MAS             shift and go to state 110
    MENOS           shift and go to state 111
    MULT            shift and go to state 112
    DIVISION        shift and go to state 113
    MODULO          shift and go to state 114

    signo_arit                     shift and go to state 109

state 71

    (120) expresion -> op_mat .

    ENDLINE         reduce using rule 120 (expresion -> op_mat .)
    COMMA           reduce using rule 120 (expresion -> op_mat .)
    LLAVEDER        reduce using rule 120 (expresion -> op_mat .)
    RPAREN          reduce using rule 120 (expresion -> op_mat .)


state 72

    (121) expresion -> slice_exp .

    ENDLINE         reduce using rule 121 (expresion -> slice_exp .)
    COMMA           reduce using rule 121 (expresion -> slice_exp .)
    LLAVEDER        reduce using rule 121 (expresion -> slice_exp .)
    RPAREN          reduce using rule 121 (expresion -> slice_exp .)


state 73

    (71) op_mat -> art_exp .

    ENDLINE         reduce using rule 71 (op_mat -> art_exp .)
    COMMA           reduce using rule 71 (op_mat -> art_exp .)
    LLAVEDER        reduce using rule 71 (op_mat -> art_exp .)
    RPAREN          reduce using rule 71 (op_mat -> art_exp .)


state 74

    (72) op_mat -> VARIABLE . signo_arit art_exp
    (74) art_exp -> VARIABLE . signo_arit VARIABLE
    (76) art_exp -> VARIABLE . signo_arit U8
    (78) signo_arit -> . MAS
    (79) signo_arit -> . MENOS
    (80) signo_arit -> . MULT
    (81) signo_arit -> . DIVISION
    (82) signo_arit -> . MODULO

    MAS             shift and go to state 110
    MENOS           shift and go to state 111
    MULT            shift and go to state 112
    DIVISION        shift and go to state 113
    MODULO          shift and go to state 114

    signo_arit                     shift and go to state 115

state 75

    (84) slice_exp -> AND . empty VARIABLE empty BRACKETL rango BRACKETR
    (89) empty -> .

    VARIABLE        reduce using rule 89 (empty -> .)

    empty                          shift and go to state 116

state 76

    (32) prints -> PRINTS LPAREN print_expresion . RPAREN ENDLINE

    RPAREN          shift and go to state 117


state 77

    (33) print_expresion -> STRING .
    (34) print_expresion -> STRING . COMMA print_args

    RPAREN          reduce using rule 33 (print_expresion -> STRING .)
    COMMA           shift and go to state 118


state 78

    (38) hashset -> LET MUT VARIABLE . ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (109) declare_vector -> LET MUT VARIABLE . ASIGNATION_TYPE
    (25) var_tipo -> VARIABLE .
    (26) var_tipo -> VARIABLE . ASIGNATION_TYPE tipos

  ! shift/reduce conflict for ASIGNAR resolved as shift
    ASIGNAR         shift and go to state 119
    ASIGNATION_TYPE shift and go to state 120

  ! ASIGNAR         [ reduce using rule 25 (var_tipo -> VARIABLE .) ]


state 79

    (24) let_asig -> LET MUT var_tipo .

    ASIGNAR         reduce using rule 24 (let_asig -> LET MUT var_tipo .)


state 80

    (110) declare_vector -> LET VARIABLE ASIGNATION_TYPE .
    (26) var_tipo -> VARIABLE ASIGNATION_TYPE . tipos
    (116) tipos -> . DATATYPES
    (117) tipos -> . NUMDATATYPES

    VECT            reduce using rule 110 (declare_vector -> LET VARIABLE ASIGNATION_TYPE .)
    ASIGNAR         reduce using rule 110 (declare_vector -> LET VARIABLE ASIGNATION_TYPE .)
    VECTMACRO       reduce using rule 110 (declare_vector -> LET VARIABLE ASIGNATION_TYPE .)
    DATATYPES       shift and go to state 122
    NUMDATATYPES    shift and go to state 123

    tipos                          shift and go to state 121

state 81

    (114) vector_methods -> VARIABLE empty DOT . empty PUSH_VEC LPAREN expresion RPAREN
    (115) vector_methods -> VARIABLE empty DOT . empty POP_VEC LPAREN RPAREN
    (85) slice_get -> VARIABLE empty DOT . empty GET_SLICE empty LPAREN valor_get RPAREN
    (88) slice_contains -> VARIABLE empty DOT . empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (89) empty -> .

    PUSH_VEC        reduce using rule 89 (empty -> .)
    POP_VEC         reduce using rule 89 (empty -> .)
    GET_SLICE       reduce using rule 89 (empty -> .)
    CONTAINS_SLICE  reduce using rule 89 (empty -> .)

    empty                          shift and go to state 124

state 82

    (41) hashset_insert -> VARIABLE DOT INSERT_HASH . LPAREN expresion RPAREN ENDLINE

    LPAREN          shift and go to state 125


state 83

    (42) hashset_union -> VARIABLE DOT UNION_HASH . LPAREN AND VARIABLE RPAREN ENDLINE

    LPAREN          shift and go to state 126


state 84

    (20) other_operators -> VARIABLE oper_asig expresion .

    ENDLINE         reduce using rule 20 (other_operators -> VARIABLE oper_asig expresion .)


state 85

    (44) conditional -> if_type validations LLAVEIZ . rust LLAVEDER
    (1) rust -> . asignacion
    (2) rust -> . prints
    (3) rust -> . hashset
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . while_loop
    (10) rust -> . empty_vector
    (11) rust -> . vector_methods
    (12) rust -> . data_vector
    (13) rust -> . slice_get
    (14) rust -> . slice_contains
    (15) rust -> . read_data
    (16) rust -> . function
    (17) rust -> . empty_function
    (18) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (19) asignacion -> . other_operators ENDLINE
    (32) prints -> . PRINTS LPAREN print_expresion RPAREN ENDLINE
    (38) hashset -> . LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (39) hashfunc -> . hashset_insert
    (40) hashfunc -> . hashset_union
    (44) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (43) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (61) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (62) struct_s -> . STRUCT sent_stru
    (90) while_loop -> . WHILE validations LLAVEIZ rust LLAVEDER
    (97) empty_vector -> . declare_vector VECT types_vector empty_vec
    (114) vector_methods -> . VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (115) vector_methods -> . VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
    (98) data_vector -> . declare_vector VECT types_vector vector_content
    (99) data_vector -> . declare_vector vector_content
    (100) data_vector -> . declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE
    (85) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (88) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (91) read_data -> . IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (93) function -> . FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (94) empty_function -> . FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
    (21) declarador -> . VARIABLE
    (22) declarador -> . let_asig
    (20) other_operators -> . VARIABLE oper_asig expresion
    (41) hashset_insert -> . VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (42) hashset_union -> . VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
    (45) if_type -> . IF
    (46) if_type -> . ELSE IF
    (47) if_type -> . ELSE
    (109) declare_vector -> . LET MUT VARIABLE ASIGNATION_TYPE
    (110) declare_vector -> . LET VARIABLE ASIGNATION_TYPE
    (23) let_asig -> . LET var_tipo
    (24) let_asig -> . LET MUT var_tipo

    PRINTS          shift and go to state 21
    LET             shift and go to state 22
    FOR             shift and go to state 27
    STRUCT          shift and go to state 28
    WHILE           shift and go to state 29
    VARIABLE        shift and go to state 23
    IO              shift and go to state 31
    FUNCTION        shift and go to state 32
    IF              shift and go to state 34
    ELSE            shift and go to state 35

    if_type                        shift and go to state 26
    rust                           shift and go to state 127
    asignacion                     shift and go to state 2
    prints                         shift and go to state 3
    hashset                        shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    while_loop                     shift and go to state 10
    empty_vector                   shift and go to state 11
    vector_methods                 shift and go to state 12
    data_vector                    shift and go to state 13
    slice_get                      shift and go to state 14
    slice_contains                 shift and go to state 15
    read_data                      shift and go to state 16
    function                       shift and go to state 17
    empty_function                 shift and go to state 18
    declarador                     shift and go to state 19
    other_operators                shift and go to state 20
    hashset_insert                 shift and go to state 24
    hashset_union                  shift and go to state 25
    declare_vector                 shift and go to state 30
    let_asig                       shift and go to state 33

state 86

    (49) validations -> comparison ANDAND . validations
    (48) validations -> . comparison
    (49) validations -> . comparison ANDAND validations
    (50) validations -> . comparison OROR validations
    (51) comparison -> . VARIABLE signo_comp VARIABLE
    (52) comparison -> . VARIABLE signo_comp U8
    (53) comparison -> . U8 signo_comp VARIABLE

    VARIABLE        shift and go to state 52
    U8              shift and go to state 53

    comparison                     shift and go to state 51
    validations                    shift and go to state 128

state 87

    (50) validations -> comparison OROR . validations
    (48) validations -> . comparison
    (49) validations -> . comparison ANDAND validations
    (50) validations -> . comparison OROR validations
    (51) comparison -> . VARIABLE signo_comp VARIABLE
    (52) comparison -> . VARIABLE signo_comp U8
    (53) comparison -> . U8 signo_comp VARIABLE

    VARIABLE        shift and go to state 52
    U8              shift and go to state 53

    comparison                     shift and go to state 51
    validations                    shift and go to state 129

state 88

    (51) comparison -> VARIABLE signo_comp . VARIABLE
    (52) comparison -> VARIABLE signo_comp . U8

    VARIABLE        shift and go to state 130
    U8              shift and go to state 131


state 89

    (54) signo_comp -> GREATER .

    VARIABLE        reduce using rule 54 (signo_comp -> GREATER .)
    U8              reduce using rule 54 (signo_comp -> GREATER .)


state 90

    (55) signo_comp -> LESST .

    VARIABLE        reduce using rule 55 (signo_comp -> LESST .)
    U8              reduce using rule 55 (signo_comp -> LESST .)


state 91

    (56) signo_comp -> GREATEQ .

    VARIABLE        reduce using rule 56 (signo_comp -> GREATEQ .)
    U8              reduce using rule 56 (signo_comp -> GREATEQ .)


state 92

    (57) signo_comp -> EQUAL .

    VARIABLE        reduce using rule 57 (signo_comp -> EQUAL .)
    U8              reduce using rule 57 (signo_comp -> EQUAL .)


state 93

    (58) signo_comp -> DIFFERENT .

    VARIABLE        reduce using rule 58 (signo_comp -> DIFFERENT .)
    U8              reduce using rule 58 (signo_comp -> DIFFERENT .)


state 94

    (53) comparison -> U8 signo_comp . VARIABLE

    VARIABLE        shift and go to state 132


state 95

    (61) for_loop -> FOR VARIABLE IN . f_comparacion LLAVEIZ rust LLAVEDER
    (59) f_comparacion -> . rango
    (60) f_comparacion -> . VARIABLE
    (83) rango -> . U8 DOT DOT U8

    VARIABLE        shift and go to state 133
    U8              shift and go to state 136

    f_comparacion                  shift and go to state 134
    rango                          shift and go to state 135

state 96

    (68) sent_stru -> UNIT ENDLINE .

    $end            reduce using rule 68 (sent_stru -> UNIT ENDLINE .)
    LLAVEDER        reduce using rule 68 (sent_stru -> UNIT ENDLINE .)


state 97

    (69) sent_stru -> TUPLE LPAREN . argumentos_tipo RPAREN ENDLINE
    (66) argumentos_tipo -> . tipos
    (67) argumentos_tipo -> . tipos COMMA argumentos_tipo
    (116) tipos -> . DATATYPES
    (117) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 122
    NUMDATATYPES    shift and go to state 123

    argumentos_tipo                shift and go to state 137
    tipos                          shift and go to state 138

state 98

    (70) sent_stru -> VARIABLE LLAVEIZ . argumentos_juntos LLAVEDER
    (63) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos
    (64) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
    (65) argumentos_juntos -> . PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos

    VARIABLE        shift and go to state 139
    PUB             shift and go to state 141

    argumentos_juntos              shift and go to state 140

state 99

    (90) while_loop -> WHILE validations LLAVEIZ . rust LLAVEDER
    (1) rust -> . asignacion
    (2) rust -> . prints
    (3) rust -> . hashset
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . while_loop
    (10) rust -> . empty_vector
    (11) rust -> . vector_methods
    (12) rust -> . data_vector
    (13) rust -> . slice_get
    (14) rust -> . slice_contains
    (15) rust -> . read_data
    (16) rust -> . function
    (17) rust -> . empty_function
    (18) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (19) asignacion -> . other_operators ENDLINE
    (32) prints -> . PRINTS LPAREN print_expresion RPAREN ENDLINE
    (38) hashset -> . LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (39) hashfunc -> . hashset_insert
    (40) hashfunc -> . hashset_union
    (44) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (43) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (61) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (62) struct_s -> . STRUCT sent_stru
    (90) while_loop -> . WHILE validations LLAVEIZ rust LLAVEDER
    (97) empty_vector -> . declare_vector VECT types_vector empty_vec
    (114) vector_methods -> . VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (115) vector_methods -> . VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
    (98) data_vector -> . declare_vector VECT types_vector vector_content
    (99) data_vector -> . declare_vector vector_content
    (100) data_vector -> . declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE
    (85) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (88) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (91) read_data -> . IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (93) function -> . FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (94) empty_function -> . FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
    (21) declarador -> . VARIABLE
    (22) declarador -> . let_asig
    (20) other_operators -> . VARIABLE oper_asig expresion
    (41) hashset_insert -> . VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (42) hashset_union -> . VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
    (45) if_type -> . IF
    (46) if_type -> . ELSE IF
    (47) if_type -> . ELSE
    (109) declare_vector -> . LET MUT VARIABLE ASIGNATION_TYPE
    (110) declare_vector -> . LET VARIABLE ASIGNATION_TYPE
    (23) let_asig -> . LET var_tipo
    (24) let_asig -> . LET MUT var_tipo

    PRINTS          shift and go to state 21
    LET             shift and go to state 22
    FOR             shift and go to state 27
    STRUCT          shift and go to state 28
    WHILE           shift and go to state 29
    VARIABLE        shift and go to state 23
    IO              shift and go to state 31
    FUNCTION        shift and go to state 32
    IF              shift and go to state 34
    ELSE            shift and go to state 35

    rust                           shift and go to state 142
    asignacion                     shift and go to state 2
    prints                         shift and go to state 3
    hashset                        shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    while_loop                     shift and go to state 10
    empty_vector                   shift and go to state 11
    vector_methods                 shift and go to state 12
    data_vector                    shift and go to state 13
    slice_get                      shift and go to state 14
    slice_contains                 shift and go to state 15
    read_data                      shift and go to state 16
    function                       shift and go to state 17
    empty_function                 shift and go to state 18
    declarador                     shift and go to state 19
    other_operators                shift and go to state 20
    hashset_insert                 shift and go to state 24
    hashset_union                  shift and go to state 25
    if_type                        shift and go to state 26
    declare_vector                 shift and go to state 30
    let_asig                       shift and go to state 33

state 100

    (97) empty_vector -> declare_vector VECT types_vector . empty_vec
    (98) data_vector -> declare_vector VECT types_vector . vector_content
    (111) empty_vec -> . ASIGNAR VECT PATHSEP NEWFUNC ENDLINE
    (112) empty_vec -> . ASIGNAR VECTMACRO BRACKETL BRACKETR ENDLINE
    (113) empty_vec -> . ASIGNAR VECT PATHSEP FROM LPAREN RPAREN ENDLINE
    (101) vector_content -> . VECTMACRO LLAVEIZ vector_elements LLAVEDER ENDLINE
    (102) vector_content -> . VECT empty PATHSEP empty FROM LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE

    ASIGNAR         shift and go to state 146
    VECTMACRO       shift and go to state 63
    VECT            shift and go to state 143

    empty_vec                      shift and go to state 144
    vector_content                 shift and go to state 145

state 101

    (102) vector_content -> VECT empty . PATHSEP empty FROM LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE

    PATHSEP         shift and go to state 147


state 102

    (107) types_vector -> LESST . DATATYPES GREATER
    (108) types_vector -> LESST . NUMDATATYPES GREATER

    DATATYPES       shift and go to state 148
    NUMDATATYPES    shift and go to state 149


state 103

    (100) data_vector -> declare_vector ASIGNAR VECTMACRO . LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE

    LLAVEIZ         shift and go to state 150


state 104

    (101) vector_content -> VECTMACRO LLAVEIZ . vector_elements LLAVEDER ENDLINE
    (103) vector_elements -> . element
    (104) vector_elements -> . element COMMA vector_elements
    (105) element -> . expresion
    (118) expresion -> . STRING
    (119) expresion -> . U8
    (120) expresion -> . op_mat
    (121) expresion -> . slice_exp
    (71) op_mat -> . art_exp
    (72) op_mat -> . VARIABLE signo_arit art_exp
    (73) op_mat -> . U8 signo_arit art_exp
    (84) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (74) art_exp -> . VARIABLE signo_arit VARIABLE
    (75) art_exp -> . U8 signo_arit VARIABLE
    (76) art_exp -> . VARIABLE signo_arit U8
    (77) art_exp -> . U8 signo_arit U8

    STRING          shift and go to state 69
    U8              shift and go to state 70
    VARIABLE        shift and go to state 74
    AND             shift and go to state 75

    vector_elements                shift and go to state 151
    element                        shift and go to state 152
    expresion                      shift and go to state 153
    op_mat                         shift and go to state 71
    slice_exp                      shift and go to state 72
    art_exp                        shift and go to state 73

state 105

    (91) read_data -> IO empty PATHSEP . empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (89) empty -> .

    STDIN           reduce using rule 89 (empty -> .)

    empty                          shift and go to state 154

state 106

    (93) function -> FUNCTION VARIABLE LPAREN . arguments RPAREN LLAVEIZ rust LLAVEDER
    (94) empty_function -> FUNCTION VARIABLE LPAREN . RPAREN LLAVEIZ rust LLAVEDER
    (95) arguments -> . VARIABLE ASIGNATION_TYPE tipos
    (96) arguments -> . VARIABLE ASIGNATION_TYPE tipos COMMA arguments

    RPAREN          shift and go to state 157
    VARIABLE        shift and go to state 155

    arguments                      shift and go to state 156

state 107

    (18) asignacion -> declarador ASIGNAR expresion ENDLINE .

    $end            reduce using rule 18 (asignacion -> declarador ASIGNAR expresion ENDLINE .)
    LLAVEDER        reduce using rule 18 (asignacion -> declarador ASIGNAR expresion ENDLINE .)


state 108

    (43) conditional_asigned -> declarador ASIGNAR conditional ENDLINE .

    $end            reduce using rule 43 (conditional_asigned -> declarador ASIGNAR conditional ENDLINE .)
    LLAVEDER        reduce using rule 43 (conditional_asigned -> declarador ASIGNAR conditional ENDLINE .)


state 109

    (73) op_mat -> U8 signo_arit . art_exp
    (75) art_exp -> U8 signo_arit . VARIABLE
    (77) art_exp -> U8 signo_arit . U8
    (74) art_exp -> . VARIABLE signo_arit VARIABLE
    (75) art_exp -> . U8 signo_arit VARIABLE
    (76) art_exp -> . VARIABLE signo_arit U8
    (77) art_exp -> . U8 signo_arit U8

    VARIABLE        shift and go to state 160
    U8              shift and go to state 158

    art_exp                        shift and go to state 159

state 110

    (78) signo_arit -> MAS .

    VARIABLE        reduce using rule 78 (signo_arit -> MAS .)
    U8              reduce using rule 78 (signo_arit -> MAS .)


state 111

    (79) signo_arit -> MENOS .

    VARIABLE        reduce using rule 79 (signo_arit -> MENOS .)
    U8              reduce using rule 79 (signo_arit -> MENOS .)


state 112

    (80) signo_arit -> MULT .

    VARIABLE        reduce using rule 80 (signo_arit -> MULT .)
    U8              reduce using rule 80 (signo_arit -> MULT .)


state 113

    (81) signo_arit -> DIVISION .

    VARIABLE        reduce using rule 81 (signo_arit -> DIVISION .)
    U8              reduce using rule 81 (signo_arit -> DIVISION .)


state 114

    (82) signo_arit -> MODULO .

    VARIABLE        reduce using rule 82 (signo_arit -> MODULO .)
    U8              reduce using rule 82 (signo_arit -> MODULO .)


state 115

    (72) op_mat -> VARIABLE signo_arit . art_exp
    (74) art_exp -> VARIABLE signo_arit . VARIABLE
    (76) art_exp -> VARIABLE signo_arit . U8
    (74) art_exp -> . VARIABLE signo_arit VARIABLE
    (75) art_exp -> . U8 signo_arit VARIABLE
    (76) art_exp -> . VARIABLE signo_arit U8
    (77) art_exp -> . U8 signo_arit U8

    VARIABLE        shift and go to state 161
    U8              shift and go to state 163

    art_exp                        shift and go to state 162

state 116

    (84) slice_exp -> AND empty . VARIABLE empty BRACKETL rango BRACKETR

    VARIABLE        shift and go to state 164


state 117

    (32) prints -> PRINTS LPAREN print_expresion RPAREN . ENDLINE

    ENDLINE         shift and go to state 165


state 118

    (34) print_expresion -> STRING COMMA . print_args
    (35) print_args -> . print_datos COMMA print_args
    (36) print_args -> . print_datos
    (37) print_datos -> . expresion
    (118) expresion -> . STRING
    (119) expresion -> . U8
    (120) expresion -> . op_mat
    (121) expresion -> . slice_exp
    (71) op_mat -> . art_exp
    (72) op_mat -> . VARIABLE signo_arit art_exp
    (73) op_mat -> . U8 signo_arit art_exp
    (84) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (74) art_exp -> . VARIABLE signo_arit VARIABLE
    (75) art_exp -> . U8 signo_arit VARIABLE
    (76) art_exp -> . VARIABLE signo_arit U8
    (77) art_exp -> . U8 signo_arit U8

    STRING          shift and go to state 69
    U8              shift and go to state 70
    VARIABLE        shift and go to state 74
    AND             shift and go to state 75

    print_args                     shift and go to state 166
    print_datos                    shift and go to state 167
    expresion                      shift and go to state 168
    op_mat                         shift and go to state 71
    slice_exp                      shift and go to state 72
    art_exp                        shift and go to state 73

state 119

    (38) hashset -> LET MUT VARIABLE ASIGNAR . HASHSET PATHSEP NEWFUNC ENDLINE

    HASHSET         shift and go to state 169


state 120

    (109) declare_vector -> LET MUT VARIABLE ASIGNATION_TYPE .
    (26) var_tipo -> VARIABLE ASIGNATION_TYPE . tipos
    (116) tipos -> . DATATYPES
    (117) tipos -> . NUMDATATYPES

    VECT            reduce using rule 109 (declare_vector -> LET MUT VARIABLE ASIGNATION_TYPE .)
    ASIGNAR         reduce using rule 109 (declare_vector -> LET MUT VARIABLE ASIGNATION_TYPE .)
    VECTMACRO       reduce using rule 109 (declare_vector -> LET MUT VARIABLE ASIGNATION_TYPE .)
    DATATYPES       shift and go to state 122
    NUMDATATYPES    shift and go to state 123

    tipos                          shift and go to state 121

state 121

    (26) var_tipo -> VARIABLE ASIGNATION_TYPE tipos .

    ASIGNAR         reduce using rule 26 (var_tipo -> VARIABLE ASIGNATION_TYPE tipos .)


state 122

    (116) tipos -> DATATYPES .

    ASIGNAR         reduce using rule 116 (tipos -> DATATYPES .)
    COMMA           reduce using rule 116 (tipos -> DATATYPES .)
    RPAREN          reduce using rule 116 (tipos -> DATATYPES .)
    LLAVEDER        reduce using rule 116 (tipos -> DATATYPES .)


state 123

    (117) tipos -> NUMDATATYPES .

    ASIGNAR         reduce using rule 117 (tipos -> NUMDATATYPES .)
    COMMA           reduce using rule 117 (tipos -> NUMDATATYPES .)
    RPAREN          reduce using rule 117 (tipos -> NUMDATATYPES .)
    LLAVEDER        reduce using rule 117 (tipos -> NUMDATATYPES .)


state 124

    (114) vector_methods -> VARIABLE empty DOT empty . PUSH_VEC LPAREN expresion RPAREN
    (115) vector_methods -> VARIABLE empty DOT empty . POP_VEC LPAREN RPAREN
    (85) slice_get -> VARIABLE empty DOT empty . GET_SLICE empty LPAREN valor_get RPAREN
    (88) slice_contains -> VARIABLE empty DOT empty . CONTAINS_SLICE empty LPAREN AND U8 RPAREN

    PUSH_VEC        shift and go to state 170
    POP_VEC         shift and go to state 171
    GET_SLICE       shift and go to state 172
    CONTAINS_SLICE  shift and go to state 173


state 125

    (41) hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN . expresion RPAREN ENDLINE
    (118) expresion -> . STRING
    (119) expresion -> . U8
    (120) expresion -> . op_mat
    (121) expresion -> . slice_exp
    (71) op_mat -> . art_exp
    (72) op_mat -> . VARIABLE signo_arit art_exp
    (73) op_mat -> . U8 signo_arit art_exp
    (84) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (74) art_exp -> . VARIABLE signo_arit VARIABLE
    (75) art_exp -> . U8 signo_arit VARIABLE
    (76) art_exp -> . VARIABLE signo_arit U8
    (77) art_exp -> . U8 signo_arit U8

    STRING          shift and go to state 69
    U8              shift and go to state 70
    VARIABLE        shift and go to state 74
    AND             shift and go to state 75

    expresion                      shift and go to state 174
    op_mat                         shift and go to state 71
    slice_exp                      shift and go to state 72
    art_exp                        shift and go to state 73

state 126

    (42) hashset_union -> VARIABLE DOT UNION_HASH LPAREN . AND VARIABLE RPAREN ENDLINE

    AND             shift and go to state 175


state 127

    (44) conditional -> if_type validations LLAVEIZ rust . LLAVEDER

    LLAVEDER        shift and go to state 176


state 128

    (49) validations -> comparison ANDAND validations .

    LLAVEIZ         reduce using rule 49 (validations -> comparison ANDAND validations .)


state 129

    (50) validations -> comparison OROR validations .

    LLAVEIZ         reduce using rule 50 (validations -> comparison OROR validations .)


state 130

    (51) comparison -> VARIABLE signo_comp VARIABLE .

    ANDAND          reduce using rule 51 (comparison -> VARIABLE signo_comp VARIABLE .)
    OROR            reduce using rule 51 (comparison -> VARIABLE signo_comp VARIABLE .)
    LLAVEIZ         reduce using rule 51 (comparison -> VARIABLE signo_comp VARIABLE .)


state 131

    (52) comparison -> VARIABLE signo_comp U8 .

    ANDAND          reduce using rule 52 (comparison -> VARIABLE signo_comp U8 .)
    OROR            reduce using rule 52 (comparison -> VARIABLE signo_comp U8 .)
    LLAVEIZ         reduce using rule 52 (comparison -> VARIABLE signo_comp U8 .)


state 132

    (53) comparison -> U8 signo_comp VARIABLE .

    ANDAND          reduce using rule 53 (comparison -> U8 signo_comp VARIABLE .)
    OROR            reduce using rule 53 (comparison -> U8 signo_comp VARIABLE .)
    LLAVEIZ         reduce using rule 53 (comparison -> U8 signo_comp VARIABLE .)


state 133

    (60) f_comparacion -> VARIABLE .

    LLAVEIZ         reduce using rule 60 (f_comparacion -> VARIABLE .)


state 134

    (61) for_loop -> FOR VARIABLE IN f_comparacion . LLAVEIZ rust LLAVEDER

    LLAVEIZ         shift and go to state 177


state 135

    (59) f_comparacion -> rango .

    LLAVEIZ         reduce using rule 59 (f_comparacion -> rango .)


state 136

    (83) rango -> U8 . DOT DOT U8

    DOT             shift and go to state 178


state 137

    (69) sent_stru -> TUPLE LPAREN argumentos_tipo . RPAREN ENDLINE

    RPAREN          shift and go to state 179


state 138

    (66) argumentos_tipo -> tipos .
    (67) argumentos_tipo -> tipos . COMMA argumentos_tipo

    RPAREN          reduce using rule 66 (argumentos_tipo -> tipos .)
    COMMA           shift and go to state 180


state 139

    (63) argumentos_juntos -> VARIABLE . ASIGNATION_TYPE tipos
    (64) argumentos_juntos -> VARIABLE . ASIGNATION_TYPE tipos COMMA argumentos_juntos

    ASIGNATION_TYPE shift and go to state 181


state 140

    (70) sent_stru -> VARIABLE LLAVEIZ argumentos_juntos . LLAVEDER

    LLAVEDER        shift and go to state 182


state 141

    (65) argumentos_juntos -> PUB . VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos

    VARIABLE        shift and go to state 183


state 142

    (90) while_loop -> WHILE validations LLAVEIZ rust . LLAVEDER

    LLAVEDER        shift and go to state 184


state 143

    (102) vector_content -> VECT . empty PATHSEP empty FROM LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE
    (89) empty -> .

    PATHSEP         reduce using rule 89 (empty -> .)

    empty                          shift and go to state 101

state 144

    (97) empty_vector -> declare_vector VECT types_vector empty_vec .

    $end            reduce using rule 97 (empty_vector -> declare_vector VECT types_vector empty_vec .)
    LLAVEDER        reduce using rule 97 (empty_vector -> declare_vector VECT types_vector empty_vec .)


state 145

    (98) data_vector -> declare_vector VECT types_vector vector_content .

    $end            reduce using rule 98 (data_vector -> declare_vector VECT types_vector vector_content .)
    LLAVEDER        reduce using rule 98 (data_vector -> declare_vector VECT types_vector vector_content .)


state 146

    (111) empty_vec -> ASIGNAR . VECT PATHSEP NEWFUNC ENDLINE
    (112) empty_vec -> ASIGNAR . VECTMACRO BRACKETL BRACKETR ENDLINE
    (113) empty_vec -> ASIGNAR . VECT PATHSEP FROM LPAREN RPAREN ENDLINE

    VECT            shift and go to state 185
    VECTMACRO       shift and go to state 186


state 147

    (102) vector_content -> VECT empty PATHSEP . empty FROM LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE
    (89) empty -> .

    FROM            reduce using rule 89 (empty -> .)

    empty                          shift and go to state 187

state 148

    (107) types_vector -> LESST DATATYPES . GREATER

    GREATER         shift and go to state 188


state 149

    (108) types_vector -> LESST NUMDATATYPES . GREATER

    GREATER         shift and go to state 189


state 150

    (100) data_vector -> declare_vector ASIGNAR VECTMACRO LLAVEIZ . element_type COMMA vector_elements LLAVEDER ENDLINE
    (106) element_type -> . U8 NUMDATATYPES

    U8              shift and go to state 191

    element_type                   shift and go to state 190

state 151

    (101) vector_content -> VECTMACRO LLAVEIZ vector_elements . LLAVEDER ENDLINE

    LLAVEDER        shift and go to state 192


state 152

    (103) vector_elements -> element .
    (104) vector_elements -> element . COMMA vector_elements

    LLAVEDER        reduce using rule 103 (vector_elements -> element .)
    COMMA           shift and go to state 193


state 153

    (105) element -> expresion .

    COMMA           reduce using rule 105 (element -> expresion .)
    LLAVEDER        reduce using rule 105 (element -> expresion .)


state 154

    (91) read_data -> IO empty PATHSEP empty . STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE

    STDIN           shift and go to state 194


state 155

    (95) arguments -> VARIABLE . ASIGNATION_TYPE tipos
    (96) arguments -> VARIABLE . ASIGNATION_TYPE tipos COMMA arguments

    ASIGNATION_TYPE shift and go to state 195


state 156

    (93) function -> FUNCTION VARIABLE LPAREN arguments . RPAREN LLAVEIZ rust LLAVEDER

    RPAREN          shift and go to state 196


state 157

    (94) empty_function -> FUNCTION VARIABLE LPAREN RPAREN . LLAVEIZ rust LLAVEDER

    LLAVEIZ         shift and go to state 197


state 158

    (77) art_exp -> U8 signo_arit U8 .
    (75) art_exp -> U8 . signo_arit VARIABLE
    (77) art_exp -> U8 . signo_arit U8
    (78) signo_arit -> . MAS
    (79) signo_arit -> . MENOS
    (80) signo_arit -> . MULT
    (81) signo_arit -> . DIVISION
    (82) signo_arit -> . MODULO

    ENDLINE         reduce using rule 77 (art_exp -> U8 signo_arit U8 .)
    COMMA           reduce using rule 77 (art_exp -> U8 signo_arit U8 .)
    LLAVEDER        reduce using rule 77 (art_exp -> U8 signo_arit U8 .)
    RPAREN          reduce using rule 77 (art_exp -> U8 signo_arit U8 .)
    MAS             shift and go to state 110
    MENOS           shift and go to state 111
    MULT            shift and go to state 112
    DIVISION        shift and go to state 113
    MODULO          shift and go to state 114

    signo_arit                     shift and go to state 198

state 159

    (73) op_mat -> U8 signo_arit art_exp .

    ENDLINE         reduce using rule 73 (op_mat -> U8 signo_arit art_exp .)
    COMMA           reduce using rule 73 (op_mat -> U8 signo_arit art_exp .)
    LLAVEDER        reduce using rule 73 (op_mat -> U8 signo_arit art_exp .)
    RPAREN          reduce using rule 73 (op_mat -> U8 signo_arit art_exp .)


state 160

    (75) art_exp -> U8 signo_arit VARIABLE .
    (74) art_exp -> VARIABLE . signo_arit VARIABLE
    (76) art_exp -> VARIABLE . signo_arit U8
    (78) signo_arit -> . MAS
    (79) signo_arit -> . MENOS
    (80) signo_arit -> . MULT
    (81) signo_arit -> . DIVISION
    (82) signo_arit -> . MODULO

    ENDLINE         reduce using rule 75 (art_exp -> U8 signo_arit VARIABLE .)
    COMMA           reduce using rule 75 (art_exp -> U8 signo_arit VARIABLE .)
    LLAVEDER        reduce using rule 75 (art_exp -> U8 signo_arit VARIABLE .)
    RPAREN          reduce using rule 75 (art_exp -> U8 signo_arit VARIABLE .)
    MAS             shift and go to state 110
    MENOS           shift and go to state 111
    MULT            shift and go to state 112
    DIVISION        shift and go to state 113
    MODULO          shift and go to state 114

    signo_arit                     shift and go to state 199

state 161

    (74) art_exp -> VARIABLE signo_arit VARIABLE .
    (74) art_exp -> VARIABLE . signo_arit VARIABLE
    (76) art_exp -> VARIABLE . signo_arit U8
    (78) signo_arit -> . MAS
    (79) signo_arit -> . MENOS
    (80) signo_arit -> . MULT
    (81) signo_arit -> . DIVISION
    (82) signo_arit -> . MODULO

    ENDLINE         reduce using rule 74 (art_exp -> VARIABLE signo_arit VARIABLE .)
    COMMA           reduce using rule 74 (art_exp -> VARIABLE signo_arit VARIABLE .)
    LLAVEDER        reduce using rule 74 (art_exp -> VARIABLE signo_arit VARIABLE .)
    RPAREN          reduce using rule 74 (art_exp -> VARIABLE signo_arit VARIABLE .)
    MAS             shift and go to state 110
    MENOS           shift and go to state 111
    MULT            shift and go to state 112
    DIVISION        shift and go to state 113
    MODULO          shift and go to state 114

    signo_arit                     shift and go to state 199

state 162

    (72) op_mat -> VARIABLE signo_arit art_exp .

    ENDLINE         reduce using rule 72 (op_mat -> VARIABLE signo_arit art_exp .)
    COMMA           reduce using rule 72 (op_mat -> VARIABLE signo_arit art_exp .)
    LLAVEDER        reduce using rule 72 (op_mat -> VARIABLE signo_arit art_exp .)
    RPAREN          reduce using rule 72 (op_mat -> VARIABLE signo_arit art_exp .)


state 163

    (76) art_exp -> VARIABLE signo_arit U8 .
    (75) art_exp -> U8 . signo_arit VARIABLE
    (77) art_exp -> U8 . signo_arit U8
    (78) signo_arit -> . MAS
    (79) signo_arit -> . MENOS
    (80) signo_arit -> . MULT
    (81) signo_arit -> . DIVISION
    (82) signo_arit -> . MODULO

    ENDLINE         reduce using rule 76 (art_exp -> VARIABLE signo_arit U8 .)
    COMMA           reduce using rule 76 (art_exp -> VARIABLE signo_arit U8 .)
    LLAVEDER        reduce using rule 76 (art_exp -> VARIABLE signo_arit U8 .)
    RPAREN          reduce using rule 76 (art_exp -> VARIABLE signo_arit U8 .)
    MAS             shift and go to state 110
    MENOS           shift and go to state 111
    MULT            shift and go to state 112
    DIVISION        shift and go to state 113
    MODULO          shift and go to state 114

    signo_arit                     shift and go to state 198

state 164

    (84) slice_exp -> AND empty VARIABLE . empty BRACKETL rango BRACKETR
    (89) empty -> .

    BRACKETL        reduce using rule 89 (empty -> .)

    empty                          shift and go to state 200

state 165

    (32) prints -> PRINTS LPAREN print_expresion RPAREN ENDLINE .

    $end            reduce using rule 32 (prints -> PRINTS LPAREN print_expresion RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 32 (prints -> PRINTS LPAREN print_expresion RPAREN ENDLINE .)


state 166

    (34) print_expresion -> STRING COMMA print_args .

    RPAREN          reduce using rule 34 (print_expresion -> STRING COMMA print_args .)


state 167

    (35) print_args -> print_datos . COMMA print_args
    (36) print_args -> print_datos .

    COMMA           shift and go to state 201
    RPAREN          reduce using rule 36 (print_args -> print_datos .)


state 168

    (37) print_datos -> expresion .

    COMMA           reduce using rule 37 (print_datos -> expresion .)
    RPAREN          reduce using rule 37 (print_datos -> expresion .)


state 169

    (38) hashset -> LET MUT VARIABLE ASIGNAR HASHSET . PATHSEP NEWFUNC ENDLINE

    PATHSEP         shift and go to state 202


state 170

    (114) vector_methods -> VARIABLE empty DOT empty PUSH_VEC . LPAREN expresion RPAREN

    LPAREN          shift and go to state 203


state 171

    (115) vector_methods -> VARIABLE empty DOT empty POP_VEC . LPAREN RPAREN

    LPAREN          shift and go to state 204


state 172

    (85) slice_get -> VARIABLE empty DOT empty GET_SLICE . empty LPAREN valor_get RPAREN
    (89) empty -> .

    LPAREN          reduce using rule 89 (empty -> .)

    empty                          shift and go to state 205

state 173

    (88) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE . empty LPAREN AND U8 RPAREN
    (89) empty -> .

    LPAREN          reduce using rule 89 (empty -> .)

    empty                          shift and go to state 206

state 174

    (41) hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN expresion . RPAREN ENDLINE

    RPAREN          shift and go to state 207


state 175

    (42) hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND . VARIABLE RPAREN ENDLINE

    VARIABLE        shift and go to state 208


state 176

    (44) conditional -> if_type validations LLAVEIZ rust LLAVEDER .

    $end            reduce using rule 44 (conditional -> if_type validations LLAVEIZ rust LLAVEDER .)
    ENDLINE         reduce using rule 44 (conditional -> if_type validations LLAVEIZ rust LLAVEDER .)
    LLAVEDER        reduce using rule 44 (conditional -> if_type validations LLAVEIZ rust LLAVEDER .)


state 177

    (61) for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ . rust LLAVEDER
    (1) rust -> . asignacion
    (2) rust -> . prints
    (3) rust -> . hashset
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . while_loop
    (10) rust -> . empty_vector
    (11) rust -> . vector_methods
    (12) rust -> . data_vector
    (13) rust -> . slice_get
    (14) rust -> . slice_contains
    (15) rust -> . read_data
    (16) rust -> . function
    (17) rust -> . empty_function
    (18) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (19) asignacion -> . other_operators ENDLINE
    (32) prints -> . PRINTS LPAREN print_expresion RPAREN ENDLINE
    (38) hashset -> . LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (39) hashfunc -> . hashset_insert
    (40) hashfunc -> . hashset_union
    (44) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (43) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (61) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (62) struct_s -> . STRUCT sent_stru
    (90) while_loop -> . WHILE validations LLAVEIZ rust LLAVEDER
    (97) empty_vector -> . declare_vector VECT types_vector empty_vec
    (114) vector_methods -> . VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (115) vector_methods -> . VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
    (98) data_vector -> . declare_vector VECT types_vector vector_content
    (99) data_vector -> . declare_vector vector_content
    (100) data_vector -> . declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE
    (85) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (88) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (91) read_data -> . IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (93) function -> . FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (94) empty_function -> . FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
    (21) declarador -> . VARIABLE
    (22) declarador -> . let_asig
    (20) other_operators -> . VARIABLE oper_asig expresion
    (41) hashset_insert -> . VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (42) hashset_union -> . VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
    (45) if_type -> . IF
    (46) if_type -> . ELSE IF
    (47) if_type -> . ELSE
    (109) declare_vector -> . LET MUT VARIABLE ASIGNATION_TYPE
    (110) declare_vector -> . LET VARIABLE ASIGNATION_TYPE
    (23) let_asig -> . LET var_tipo
    (24) let_asig -> . LET MUT var_tipo

    PRINTS          shift and go to state 21
    LET             shift and go to state 22
    FOR             shift and go to state 27
    STRUCT          shift and go to state 28
    WHILE           shift and go to state 29
    VARIABLE        shift and go to state 23
    IO              shift and go to state 31
    FUNCTION        shift and go to state 32
    IF              shift and go to state 34
    ELSE            shift and go to state 35

    rust                           shift and go to state 209
    asignacion                     shift and go to state 2
    prints                         shift and go to state 3
    hashset                        shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    while_loop                     shift and go to state 10
    empty_vector                   shift and go to state 11
    vector_methods                 shift and go to state 12
    data_vector                    shift and go to state 13
    slice_get                      shift and go to state 14
    slice_contains                 shift and go to state 15
    read_data                      shift and go to state 16
    function                       shift and go to state 17
    empty_function                 shift and go to state 18
    declarador                     shift and go to state 19
    other_operators                shift and go to state 20
    hashset_insert                 shift and go to state 24
    hashset_union                  shift and go to state 25
    if_type                        shift and go to state 26
    declare_vector                 shift and go to state 30
    let_asig                       shift and go to state 33

state 178

    (83) rango -> U8 DOT . DOT U8

    DOT             shift and go to state 210


state 179

    (69) sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN . ENDLINE

    ENDLINE         shift and go to state 211


state 180

    (67) argumentos_tipo -> tipos COMMA . argumentos_tipo
    (66) argumentos_tipo -> . tipos
    (67) argumentos_tipo -> . tipos COMMA argumentos_tipo
    (116) tipos -> . DATATYPES
    (117) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 122
    NUMDATATYPES    shift and go to state 123

    tipos                          shift and go to state 138
    argumentos_tipo                shift and go to state 212

state 181

    (63) argumentos_juntos -> VARIABLE ASIGNATION_TYPE . tipos
    (64) argumentos_juntos -> VARIABLE ASIGNATION_TYPE . tipos COMMA argumentos_juntos
    (116) tipos -> . DATATYPES
    (117) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 122
    NUMDATATYPES    shift and go to state 123

    tipos                          shift and go to state 213

state 182

    (70) sent_stru -> VARIABLE LLAVEIZ argumentos_juntos LLAVEDER .

    $end            reduce using rule 70 (sent_stru -> VARIABLE LLAVEIZ argumentos_juntos LLAVEDER .)
    LLAVEDER        reduce using rule 70 (sent_stru -> VARIABLE LLAVEIZ argumentos_juntos LLAVEDER .)


state 183

    (65) argumentos_juntos -> PUB VARIABLE . ASIGNATION_TYPE tipos COMMA argumentos_juntos

    ASIGNATION_TYPE shift and go to state 214


state 184

    (90) while_loop -> WHILE validations LLAVEIZ rust LLAVEDER .

    $end            reduce using rule 90 (while_loop -> WHILE validations LLAVEIZ rust LLAVEDER .)
    LLAVEDER        reduce using rule 90 (while_loop -> WHILE validations LLAVEIZ rust LLAVEDER .)


state 185

    (111) empty_vec -> ASIGNAR VECT . PATHSEP NEWFUNC ENDLINE
    (113) empty_vec -> ASIGNAR VECT . PATHSEP FROM LPAREN RPAREN ENDLINE

    PATHSEP         shift and go to state 215


state 186

    (112) empty_vec -> ASIGNAR VECTMACRO . BRACKETL BRACKETR ENDLINE

    BRACKETL        shift and go to state 216


state 187

    (102) vector_content -> VECT empty PATHSEP empty . FROM LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE

    FROM            shift and go to state 217


state 188

    (107) types_vector -> LESST DATATYPES GREATER .

    ASIGNAR         reduce using rule 107 (types_vector -> LESST DATATYPES GREATER .)
    VECTMACRO       reduce using rule 107 (types_vector -> LESST DATATYPES GREATER .)
    VECT            reduce using rule 107 (types_vector -> LESST DATATYPES GREATER .)


state 189

    (108) types_vector -> LESST NUMDATATYPES GREATER .

    ASIGNAR         reduce using rule 108 (types_vector -> LESST NUMDATATYPES GREATER .)
    VECTMACRO       reduce using rule 108 (types_vector -> LESST NUMDATATYPES GREATER .)
    VECT            reduce using rule 108 (types_vector -> LESST NUMDATATYPES GREATER .)


state 190

    (100) data_vector -> declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type . COMMA vector_elements LLAVEDER ENDLINE

    COMMA           shift and go to state 218


state 191

    (106) element_type -> U8 . NUMDATATYPES

    NUMDATATYPES    shift and go to state 219


state 192

    (101) vector_content -> VECTMACRO LLAVEIZ vector_elements LLAVEDER . ENDLINE

    ENDLINE         shift and go to state 220


state 193

    (104) vector_elements -> element COMMA . vector_elements
    (103) vector_elements -> . element
    (104) vector_elements -> . element COMMA vector_elements
    (105) element -> . expresion
    (118) expresion -> . STRING
    (119) expresion -> . U8
    (120) expresion -> . op_mat
    (121) expresion -> . slice_exp
    (71) op_mat -> . art_exp
    (72) op_mat -> . VARIABLE signo_arit art_exp
    (73) op_mat -> . U8 signo_arit art_exp
    (84) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (74) art_exp -> . VARIABLE signo_arit VARIABLE
    (75) art_exp -> . U8 signo_arit VARIABLE
    (76) art_exp -> . VARIABLE signo_arit U8
    (77) art_exp -> . U8 signo_arit U8

    STRING          shift and go to state 69
    U8              shift and go to state 70
    VARIABLE        shift and go to state 74
    AND             shift and go to state 75

    element                        shift and go to state 152
    vector_elements                shift and go to state 221
    expresion                      shift and go to state 153
    op_mat                         shift and go to state 71
    slice_exp                      shift and go to state 72
    art_exp                        shift and go to state 73

state 194

    (91) read_data -> IO empty PATHSEP empty STDIN . LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE

    LPAREN          shift and go to state 222


state 195

    (95) arguments -> VARIABLE ASIGNATION_TYPE . tipos
    (96) arguments -> VARIABLE ASIGNATION_TYPE . tipos COMMA arguments
    (116) tipos -> . DATATYPES
    (117) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 122
    NUMDATATYPES    shift and go to state 123

    tipos                          shift and go to state 223

state 196

    (93) function -> FUNCTION VARIABLE LPAREN arguments RPAREN . LLAVEIZ rust LLAVEDER

    LLAVEIZ         shift and go to state 224


state 197

    (94) empty_function -> FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ . rust LLAVEDER
    (1) rust -> . asignacion
    (2) rust -> . prints
    (3) rust -> . hashset
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . while_loop
    (10) rust -> . empty_vector
    (11) rust -> . vector_methods
    (12) rust -> . data_vector
    (13) rust -> . slice_get
    (14) rust -> . slice_contains
    (15) rust -> . read_data
    (16) rust -> . function
    (17) rust -> . empty_function
    (18) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (19) asignacion -> . other_operators ENDLINE
    (32) prints -> . PRINTS LPAREN print_expresion RPAREN ENDLINE
    (38) hashset -> . LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (39) hashfunc -> . hashset_insert
    (40) hashfunc -> . hashset_union
    (44) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (43) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (61) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (62) struct_s -> . STRUCT sent_stru
    (90) while_loop -> . WHILE validations LLAVEIZ rust LLAVEDER
    (97) empty_vector -> . declare_vector VECT types_vector empty_vec
    (114) vector_methods -> . VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (115) vector_methods -> . VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
    (98) data_vector -> . declare_vector VECT types_vector vector_content
    (99) data_vector -> . declare_vector vector_content
    (100) data_vector -> . declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE
    (85) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (88) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (91) read_data -> . IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (93) function -> . FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (94) empty_function -> . FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
    (21) declarador -> . VARIABLE
    (22) declarador -> . let_asig
    (20) other_operators -> . VARIABLE oper_asig expresion
    (41) hashset_insert -> . VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (42) hashset_union -> . VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
    (45) if_type -> . IF
    (46) if_type -> . ELSE IF
    (47) if_type -> . ELSE
    (109) declare_vector -> . LET MUT VARIABLE ASIGNATION_TYPE
    (110) declare_vector -> . LET VARIABLE ASIGNATION_TYPE
    (23) let_asig -> . LET var_tipo
    (24) let_asig -> . LET MUT var_tipo

    PRINTS          shift and go to state 21
    LET             shift and go to state 22
    FOR             shift and go to state 27
    STRUCT          shift and go to state 28
    WHILE           shift and go to state 29
    VARIABLE        shift and go to state 23
    IO              shift and go to state 31
    FUNCTION        shift and go to state 32
    IF              shift and go to state 34
    ELSE            shift and go to state 35

    rust                           shift and go to state 225
    asignacion                     shift and go to state 2
    prints                         shift and go to state 3
    hashset                        shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    while_loop                     shift and go to state 10
    empty_vector                   shift and go to state 11
    vector_methods                 shift and go to state 12
    data_vector                    shift and go to state 13
    slice_get                      shift and go to state 14
    slice_contains                 shift and go to state 15
    read_data                      shift and go to state 16
    function                       shift and go to state 17
    empty_function                 shift and go to state 18
    declarador                     shift and go to state 19
    other_operators                shift and go to state 20
    hashset_insert                 shift and go to state 24
    hashset_union                  shift and go to state 25
    if_type                        shift and go to state 26
    declare_vector                 shift and go to state 30
    let_asig                       shift and go to state 33

state 198

    (75) art_exp -> U8 signo_arit . VARIABLE
    (77) art_exp -> U8 signo_arit . U8

    VARIABLE        shift and go to state 227
    U8              shift and go to state 226


state 199

    (74) art_exp -> VARIABLE signo_arit . VARIABLE
    (76) art_exp -> VARIABLE signo_arit . U8

    VARIABLE        shift and go to state 228
    U8              shift and go to state 229


state 200

    (84) slice_exp -> AND empty VARIABLE empty . BRACKETL rango BRACKETR

    BRACKETL        shift and go to state 230


state 201

    (35) print_args -> print_datos COMMA . print_args
    (35) print_args -> . print_datos COMMA print_args
    (36) print_args -> . print_datos
    (37) print_datos -> . expresion
    (118) expresion -> . STRING
    (119) expresion -> . U8
    (120) expresion -> . op_mat
    (121) expresion -> . slice_exp
    (71) op_mat -> . art_exp
    (72) op_mat -> . VARIABLE signo_arit art_exp
    (73) op_mat -> . U8 signo_arit art_exp
    (84) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (74) art_exp -> . VARIABLE signo_arit VARIABLE
    (75) art_exp -> . U8 signo_arit VARIABLE
    (76) art_exp -> . VARIABLE signo_arit U8
    (77) art_exp -> . U8 signo_arit U8

    STRING          shift and go to state 69
    U8              shift and go to state 70
    VARIABLE        shift and go to state 74
    AND             shift and go to state 75

    print_datos                    shift and go to state 167
    print_args                     shift and go to state 231
    expresion                      shift and go to state 168
    op_mat                         shift and go to state 71
    slice_exp                      shift and go to state 72
    art_exp                        shift and go to state 73

state 202

    (38) hashset -> LET MUT VARIABLE ASIGNAR HASHSET PATHSEP . NEWFUNC ENDLINE

    NEWFUNC         shift and go to state 232


state 203

    (114) vector_methods -> VARIABLE empty DOT empty PUSH_VEC LPAREN . expresion RPAREN
    (118) expresion -> . STRING
    (119) expresion -> . U8
    (120) expresion -> . op_mat
    (121) expresion -> . slice_exp
    (71) op_mat -> . art_exp
    (72) op_mat -> . VARIABLE signo_arit art_exp
    (73) op_mat -> . U8 signo_arit art_exp
    (84) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (74) art_exp -> . VARIABLE signo_arit VARIABLE
    (75) art_exp -> . U8 signo_arit VARIABLE
    (76) art_exp -> . VARIABLE signo_arit U8
    (77) art_exp -> . U8 signo_arit U8

    STRING          shift and go to state 69
    U8              shift and go to state 70
    VARIABLE        shift and go to state 74
    AND             shift and go to state 75

    expresion                      shift and go to state 233
    op_mat                         shift and go to state 71
    slice_exp                      shift and go to state 72
    art_exp                        shift and go to state 73

state 204

    (115) vector_methods -> VARIABLE empty DOT empty POP_VEC LPAREN . RPAREN

    RPAREN          shift and go to state 234


state 205

    (85) slice_get -> VARIABLE empty DOT empty GET_SLICE empty . LPAREN valor_get RPAREN

    LPAREN          shift and go to state 235


state 206

    (88) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty . LPAREN AND U8 RPAREN

    LPAREN          shift and go to state 236


state 207

    (41) hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN . ENDLINE

    ENDLINE         shift and go to state 237


state 208

    (42) hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND VARIABLE . RPAREN ENDLINE

    RPAREN          shift and go to state 238


state 209

    (61) for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust . LLAVEDER

    LLAVEDER        shift and go to state 239


state 210

    (83) rango -> U8 DOT DOT . U8

    U8              shift and go to state 240


state 211

    (69) sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN ENDLINE .

    $end            reduce using rule 69 (sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 69 (sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN ENDLINE .)


state 212

    (67) argumentos_tipo -> tipos COMMA argumentos_tipo .

    RPAREN          reduce using rule 67 (argumentos_tipo -> tipos COMMA argumentos_tipo .)


state 213

    (63) argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos .
    (64) argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos . COMMA argumentos_juntos

    LLAVEDER        reduce using rule 63 (argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos .)
    COMMA           shift and go to state 241


state 214

    (65) argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE . tipos COMMA argumentos_juntos
    (116) tipos -> . DATATYPES
    (117) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 122
    NUMDATATYPES    shift and go to state 123

    tipos                          shift and go to state 242

state 215

    (111) empty_vec -> ASIGNAR VECT PATHSEP . NEWFUNC ENDLINE
    (113) empty_vec -> ASIGNAR VECT PATHSEP . FROM LPAREN RPAREN ENDLINE

    NEWFUNC         shift and go to state 243
    FROM            shift and go to state 244


state 216

    (112) empty_vec -> ASIGNAR VECTMACRO BRACKETL . BRACKETR ENDLINE

    BRACKETR        shift and go to state 245


state 217

    (102) vector_content -> VECT empty PATHSEP empty FROM . LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE

    LPAREN          shift and go to state 246


state 218

    (100) data_vector -> declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA . vector_elements LLAVEDER ENDLINE
    (103) vector_elements -> . element
    (104) vector_elements -> . element COMMA vector_elements
    (105) element -> . expresion
    (118) expresion -> . STRING
    (119) expresion -> . U8
    (120) expresion -> . op_mat
    (121) expresion -> . slice_exp
    (71) op_mat -> . art_exp
    (72) op_mat -> . VARIABLE signo_arit art_exp
    (73) op_mat -> . U8 signo_arit art_exp
    (84) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (74) art_exp -> . VARIABLE signo_arit VARIABLE
    (75) art_exp -> . U8 signo_arit VARIABLE
    (76) art_exp -> . VARIABLE signo_arit U8
    (77) art_exp -> . U8 signo_arit U8

    STRING          shift and go to state 69
    U8              shift and go to state 70
    VARIABLE        shift and go to state 74
    AND             shift and go to state 75

    vector_elements                shift and go to state 247
    element                        shift and go to state 152
    expresion                      shift and go to state 153
    op_mat                         shift and go to state 71
    slice_exp                      shift and go to state 72
    art_exp                        shift and go to state 73

state 219

    (106) element_type -> U8 NUMDATATYPES .

    COMMA           reduce using rule 106 (element_type -> U8 NUMDATATYPES .)


state 220

    (101) vector_content -> VECTMACRO LLAVEIZ vector_elements LLAVEDER ENDLINE .

    $end            reduce using rule 101 (vector_content -> VECTMACRO LLAVEIZ vector_elements LLAVEDER ENDLINE .)
    LLAVEDER        reduce using rule 101 (vector_content -> VECTMACRO LLAVEIZ vector_elements LLAVEDER ENDLINE .)


state 221

    (104) vector_elements -> element COMMA vector_elements .

    LLAVEDER        reduce using rule 104 (vector_elements -> element COMMA vector_elements .)


state 222

    (91) read_data -> IO empty PATHSEP empty STDIN LPAREN . RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE

    RPAREN          shift and go to state 248


state 223

    (95) arguments -> VARIABLE ASIGNATION_TYPE tipos .
    (96) arguments -> VARIABLE ASIGNATION_TYPE tipos . COMMA arguments

    RPAREN          reduce using rule 95 (arguments -> VARIABLE ASIGNATION_TYPE tipos .)
    COMMA           shift and go to state 249


state 224

    (93) function -> FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ . rust LLAVEDER
    (1) rust -> . asignacion
    (2) rust -> . prints
    (3) rust -> . hashset
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . while_loop
    (10) rust -> . empty_vector
    (11) rust -> . vector_methods
    (12) rust -> . data_vector
    (13) rust -> . slice_get
    (14) rust -> . slice_contains
    (15) rust -> . read_data
    (16) rust -> . function
    (17) rust -> . empty_function
    (18) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (19) asignacion -> . other_operators ENDLINE
    (32) prints -> . PRINTS LPAREN print_expresion RPAREN ENDLINE
    (38) hashset -> . LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (39) hashfunc -> . hashset_insert
    (40) hashfunc -> . hashset_union
    (44) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (43) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (61) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (62) struct_s -> . STRUCT sent_stru
    (90) while_loop -> . WHILE validations LLAVEIZ rust LLAVEDER
    (97) empty_vector -> . declare_vector VECT types_vector empty_vec
    (114) vector_methods -> . VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (115) vector_methods -> . VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
    (98) data_vector -> . declare_vector VECT types_vector vector_content
    (99) data_vector -> . declare_vector vector_content
    (100) data_vector -> . declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE
    (85) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (88) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (91) read_data -> . IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (93) function -> . FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (94) empty_function -> . FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
    (21) declarador -> . VARIABLE
    (22) declarador -> . let_asig
    (20) other_operators -> . VARIABLE oper_asig expresion
    (41) hashset_insert -> . VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (42) hashset_union -> . VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
    (45) if_type -> . IF
    (46) if_type -> . ELSE IF
    (47) if_type -> . ELSE
    (109) declare_vector -> . LET MUT VARIABLE ASIGNATION_TYPE
    (110) declare_vector -> . LET VARIABLE ASIGNATION_TYPE
    (23) let_asig -> . LET var_tipo
    (24) let_asig -> . LET MUT var_tipo

    PRINTS          shift and go to state 21
    LET             shift and go to state 22
    FOR             shift and go to state 27
    STRUCT          shift and go to state 28
    WHILE           shift and go to state 29
    VARIABLE        shift and go to state 23
    IO              shift and go to state 31
    FUNCTION        shift and go to state 32
    IF              shift and go to state 34
    ELSE            shift and go to state 35

    rust                           shift and go to state 250
    asignacion                     shift and go to state 2
    prints                         shift and go to state 3
    hashset                        shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    while_loop                     shift and go to state 10
    empty_vector                   shift and go to state 11
    vector_methods                 shift and go to state 12
    data_vector                    shift and go to state 13
    slice_get                      shift and go to state 14
    slice_contains                 shift and go to state 15
    read_data                      shift and go to state 16
    function                       shift and go to state 17
    empty_function                 shift and go to state 18
    declarador                     shift and go to state 19
    other_operators                shift and go to state 20
    hashset_insert                 shift and go to state 24
    hashset_union                  shift and go to state 25
    if_type                        shift and go to state 26
    declare_vector                 shift and go to state 30
    let_asig                       shift and go to state 33

state 225

    (94) empty_function -> FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust . LLAVEDER

    LLAVEDER        shift and go to state 251


state 226

    (77) art_exp -> U8 signo_arit U8 .

    ENDLINE         reduce using rule 77 (art_exp -> U8 signo_arit U8 .)
    COMMA           reduce using rule 77 (art_exp -> U8 signo_arit U8 .)
    LLAVEDER        reduce using rule 77 (art_exp -> U8 signo_arit U8 .)
    RPAREN          reduce using rule 77 (art_exp -> U8 signo_arit U8 .)


state 227

    (75) art_exp -> U8 signo_arit VARIABLE .

    ENDLINE         reduce using rule 75 (art_exp -> U8 signo_arit VARIABLE .)
    COMMA           reduce using rule 75 (art_exp -> U8 signo_arit VARIABLE .)
    LLAVEDER        reduce using rule 75 (art_exp -> U8 signo_arit VARIABLE .)
    RPAREN          reduce using rule 75 (art_exp -> U8 signo_arit VARIABLE .)


state 228

    (74) art_exp -> VARIABLE signo_arit VARIABLE .

    ENDLINE         reduce using rule 74 (art_exp -> VARIABLE signo_arit VARIABLE .)
    COMMA           reduce using rule 74 (art_exp -> VARIABLE signo_arit VARIABLE .)
    LLAVEDER        reduce using rule 74 (art_exp -> VARIABLE signo_arit VARIABLE .)
    RPAREN          reduce using rule 74 (art_exp -> VARIABLE signo_arit VARIABLE .)


state 229

    (76) art_exp -> VARIABLE signo_arit U8 .

    ENDLINE         reduce using rule 76 (art_exp -> VARIABLE signo_arit U8 .)
    COMMA           reduce using rule 76 (art_exp -> VARIABLE signo_arit U8 .)
    LLAVEDER        reduce using rule 76 (art_exp -> VARIABLE signo_arit U8 .)
    RPAREN          reduce using rule 76 (art_exp -> VARIABLE signo_arit U8 .)


state 230

    (84) slice_exp -> AND empty VARIABLE empty BRACKETL . rango BRACKETR
    (83) rango -> . U8 DOT DOT U8

    U8              shift and go to state 136

    rango                          shift and go to state 252

state 231

    (35) print_args -> print_datos COMMA print_args .

    RPAREN          reduce using rule 35 (print_args -> print_datos COMMA print_args .)


state 232

    (38) hashset -> LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC . ENDLINE

    ENDLINE         shift and go to state 253


state 233

    (114) vector_methods -> VARIABLE empty DOT empty PUSH_VEC LPAREN expresion . RPAREN

    RPAREN          shift and go to state 254


state 234

    (115) vector_methods -> VARIABLE empty DOT empty POP_VEC LPAREN RPAREN .

    $end            reduce using rule 115 (vector_methods -> VARIABLE empty DOT empty POP_VEC LPAREN RPAREN .)
    LLAVEDER        reduce using rule 115 (vector_methods -> VARIABLE empty DOT empty POP_VEC LPAREN RPAREN .)


state 235

    (85) slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN . valor_get RPAREN
    (86) valor_get -> . rango
    (87) valor_get -> . U8
    (83) rango -> . U8 DOT DOT U8

    U8              shift and go to state 257

    valor_get                      shift and go to state 255
    rango                          shift and go to state 256

state 236

    (88) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN . AND U8 RPAREN

    AND             shift and go to state 258


state 237

    (41) hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE .

    $end            reduce using rule 41 (hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 41 (hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE .)


state 238

    (42) hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN . ENDLINE

    ENDLINE         shift and go to state 259


state 239

    (61) for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER .

    $end            reduce using rule 61 (for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER .)
    LLAVEDER        reduce using rule 61 (for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER .)


state 240

    (83) rango -> U8 DOT DOT U8 .

    LLAVEIZ         reduce using rule 83 (rango -> U8 DOT DOT U8 .)
    BRACKETR        reduce using rule 83 (rango -> U8 DOT DOT U8 .)
    RPAREN          reduce using rule 83 (rango -> U8 DOT DOT U8 .)


state 241

    (64) argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos COMMA . argumentos_juntos
    (63) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos
    (64) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
    (65) argumentos_juntos -> . PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos

    VARIABLE        shift and go to state 139
    PUB             shift and go to state 141

    argumentos_juntos              shift and go to state 260

state 242

    (65) argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos . COMMA argumentos_juntos

    COMMA           shift and go to state 261


state 243

    (111) empty_vec -> ASIGNAR VECT PATHSEP NEWFUNC . ENDLINE

    ENDLINE         shift and go to state 262


state 244

    (113) empty_vec -> ASIGNAR VECT PATHSEP FROM . LPAREN RPAREN ENDLINE

    LPAREN          shift and go to state 263


state 245

    (112) empty_vec -> ASIGNAR VECTMACRO BRACKETL BRACKETR . ENDLINE

    ENDLINE         shift and go to state 264


state 246

    (102) vector_content -> VECT empty PATHSEP empty FROM LPAREN . LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE

    LLAVEIZ         shift and go to state 265


state 247

    (100) data_vector -> declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements . LLAVEDER ENDLINE

    LLAVEDER        shift and go to state 266


state 248

    (91) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN . empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (89) empty -> .

    DOT             reduce using rule 89 (empty -> .)

    empty                          shift and go to state 267

state 249

    (96) arguments -> VARIABLE ASIGNATION_TYPE tipos COMMA . arguments
    (95) arguments -> . VARIABLE ASIGNATION_TYPE tipos
    (96) arguments -> . VARIABLE ASIGNATION_TYPE tipos COMMA arguments

    VARIABLE        shift and go to state 155

    arguments                      shift and go to state 268

state 250

    (93) function -> FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust . LLAVEDER

    LLAVEDER        shift and go to state 269


state 251

    (94) empty_function -> FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER .

    $end            reduce using rule 94 (empty_function -> FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER .)
    LLAVEDER        reduce using rule 94 (empty_function -> FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER .)


state 252

    (84) slice_exp -> AND empty VARIABLE empty BRACKETL rango . BRACKETR

    BRACKETR        shift and go to state 270


state 253

    (38) hashset -> LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE .

    $end            reduce using rule 38 (hashset -> LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE .)
    LLAVEDER        reduce using rule 38 (hashset -> LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE .)


state 254

    (114) vector_methods -> VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN .

    $end            reduce using rule 114 (vector_methods -> VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN .)
    LLAVEDER        reduce using rule 114 (vector_methods -> VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN .)


state 255

    (85) slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get . RPAREN

    RPAREN          shift and go to state 271


state 256

    (86) valor_get -> rango .

    RPAREN          reduce using rule 86 (valor_get -> rango .)


state 257

    (87) valor_get -> U8 .
    (83) rango -> U8 . DOT DOT U8

    RPAREN          reduce using rule 87 (valor_get -> U8 .)
    DOT             shift and go to state 178


state 258

    (88) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND . U8 RPAREN

    U8              shift and go to state 272


state 259

    (42) hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE .

    $end            reduce using rule 42 (hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 42 (hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE .)


state 260

    (64) argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos .

    LLAVEDER        reduce using rule 64 (argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos .)


state 261

    (65) argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos COMMA . argumentos_juntos
    (63) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos
    (64) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
    (65) argumentos_juntos -> . PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos

    VARIABLE        shift and go to state 139
    PUB             shift and go to state 141

    argumentos_juntos              shift and go to state 273

state 262

    (111) empty_vec -> ASIGNAR VECT PATHSEP NEWFUNC ENDLINE .

    $end            reduce using rule 111 (empty_vec -> ASIGNAR VECT PATHSEP NEWFUNC ENDLINE .)
    LLAVEDER        reduce using rule 111 (empty_vec -> ASIGNAR VECT PATHSEP NEWFUNC ENDLINE .)


state 263

    (113) empty_vec -> ASIGNAR VECT PATHSEP FROM LPAREN . RPAREN ENDLINE

    RPAREN          shift and go to state 274


state 264

    (112) empty_vec -> ASIGNAR VECTMACRO BRACKETL BRACKETR ENDLINE .

    $end            reduce using rule 112 (empty_vec -> ASIGNAR VECTMACRO BRACKETL BRACKETR ENDLINE .)
    LLAVEDER        reduce using rule 112 (empty_vec -> ASIGNAR VECTMACRO BRACKETL BRACKETR ENDLINE .)


state 265

    (102) vector_content -> VECT empty PATHSEP empty FROM LPAREN LLAVEIZ . vector_elements LLAVEDER RPAREN ENDLINE
    (103) vector_elements -> . element
    (104) vector_elements -> . element COMMA vector_elements
    (105) element -> . expresion
    (118) expresion -> . STRING
    (119) expresion -> . U8
    (120) expresion -> . op_mat
    (121) expresion -> . slice_exp
    (71) op_mat -> . art_exp
    (72) op_mat -> . VARIABLE signo_arit art_exp
    (73) op_mat -> . U8 signo_arit art_exp
    (84) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (74) art_exp -> . VARIABLE signo_arit VARIABLE
    (75) art_exp -> . U8 signo_arit VARIABLE
    (76) art_exp -> . VARIABLE signo_arit U8
    (77) art_exp -> . U8 signo_arit U8

    STRING          shift and go to state 69
    U8              shift and go to state 70
    VARIABLE        shift and go to state 74
    AND             shift and go to state 75

    vector_elements                shift and go to state 275
    element                        shift and go to state 152
    expresion                      shift and go to state 153
    op_mat                         shift and go to state 71
    slice_exp                      shift and go to state 72
    art_exp                        shift and go to state 73

state 266

    (100) data_vector -> declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER . ENDLINE

    ENDLINE         shift and go to state 276


state 267

    (91) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty . DOT empty READ LPAREN reference RPAREN ENDLINE

    DOT             shift and go to state 277


state 268

    (96) arguments -> VARIABLE ASIGNATION_TYPE tipos COMMA arguments .

    RPAREN          reduce using rule 96 (arguments -> VARIABLE ASIGNATION_TYPE tipos COMMA arguments .)


state 269

    (93) function -> FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER .

    $end            reduce using rule 93 (function -> FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER .)
    LLAVEDER        reduce using rule 93 (function -> FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER .)


state 270

    (84) slice_exp -> AND empty VARIABLE empty BRACKETL rango BRACKETR .

    ENDLINE         reduce using rule 84 (slice_exp -> AND empty VARIABLE empty BRACKETL rango BRACKETR .)
    COMMA           reduce using rule 84 (slice_exp -> AND empty VARIABLE empty BRACKETL rango BRACKETR .)
    LLAVEDER        reduce using rule 84 (slice_exp -> AND empty VARIABLE empty BRACKETL rango BRACKETR .)
    RPAREN          reduce using rule 84 (slice_exp -> AND empty VARIABLE empty BRACKETL rango BRACKETR .)


state 271

    (85) slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN .

    $end            reduce using rule 85 (slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN .)
    LLAVEDER        reduce using rule 85 (slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN .)


state 272

    (88) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 . RPAREN

    RPAREN          shift and go to state 278


state 273

    (65) argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos .

    LLAVEDER        reduce using rule 65 (argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos .)


state 274

    (113) empty_vec -> ASIGNAR VECT PATHSEP FROM LPAREN RPAREN . ENDLINE

    ENDLINE         shift and go to state 279


state 275

    (102) vector_content -> VECT empty PATHSEP empty FROM LPAREN LLAVEIZ vector_elements . LLAVEDER RPAREN ENDLINE

    LLAVEDER        shift and go to state 280


state 276

    (100) data_vector -> declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE .

    $end            reduce using rule 100 (data_vector -> declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE .)
    LLAVEDER        reduce using rule 100 (data_vector -> declare_vector ASIGNAR VECTMACRO LLAVEIZ element_type COMMA vector_elements LLAVEDER ENDLINE .)


state 277

    (91) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT . empty READ LPAREN reference RPAREN ENDLINE
    (89) empty -> .

    READ            reduce using rule 89 (empty -> .)

    empty                          shift and go to state 281

state 278

    (88) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN .

    $end            reduce using rule 88 (slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN .)
    LLAVEDER        reduce using rule 88 (slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN .)


state 279

    (113) empty_vec -> ASIGNAR VECT PATHSEP FROM LPAREN RPAREN ENDLINE .

    $end            reduce using rule 113 (empty_vec -> ASIGNAR VECT PATHSEP FROM LPAREN RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 113 (empty_vec -> ASIGNAR VECT PATHSEP FROM LPAREN RPAREN ENDLINE .)


state 280

    (102) vector_content -> VECT empty PATHSEP empty FROM LPAREN LLAVEIZ vector_elements LLAVEDER . RPAREN ENDLINE

    RPAREN          shift and go to state 282


state 281

    (91) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty . READ LPAREN reference RPAREN ENDLINE

    READ            shift and go to state 283


state 282

    (102) vector_content -> VECT empty PATHSEP empty FROM LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN . ENDLINE

    ENDLINE         shift and go to state 284


state 283

    (91) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ . LPAREN reference RPAREN ENDLINE

    LPAREN          shift and go to state 285


state 284

    (102) vector_content -> VECT empty PATHSEP empty FROM LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE .

    $end            reduce using rule 102 (vector_content -> VECT empty PATHSEP empty FROM LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 102 (vector_content -> VECT empty PATHSEP empty FROM LPAREN LLAVEIZ vector_elements LLAVEDER RPAREN ENDLINE .)


state 285

    (91) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN . reference RPAREN ENDLINE
    (92) reference -> . AND empty MUT VARIABLE

    AND             shift and go to state 287

    reference                      shift and go to state 286

state 286

    (91) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference . RPAREN ENDLINE

    RPAREN          shift and go to state 288


state 287

    (92) reference -> AND . empty MUT VARIABLE
    (89) empty -> .

    MUT             reduce using rule 89 (empty -> .)

    empty                          shift and go to state 289

state 288

    (91) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN . ENDLINE

    ENDLINE         shift and go to state 290


state 289

    (92) reference -> AND empty . MUT VARIABLE

    MUT             shift and go to state 291


state 290

    (91) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE .

    $end            reduce using rule 91 (read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 91 (read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE .)


state 291

    (92) reference -> AND empty MUT . VARIABLE

    VARIABLE        shift and go to state 292


state 292

    (92) reference -> AND empty MUT VARIABLE .

    RPAREN          reduce using rule 92 (reference -> AND empty MUT VARIABLE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for DOT in state 23 resolved as shift
WARNING: shift/reduce conflict for ASIGNAR in state 23 resolved as shift
WARNING: shift/reduce conflict for ASIGNAR in state 78 resolved as shift
