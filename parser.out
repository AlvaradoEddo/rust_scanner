Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARROW
    AS
    ASYNC
    AWAIT
    BREAK
    B_FALSE
    B_TRUE
    CONST
    CONTIN
    CRATE
    DOLLAR
    DOTDOTDOT
    DYN
    ENUM
    ERRORPROP
    EXTERN
    FUNCTION
    IMPL
    LESSEQ
    LOOP
    MATCH
    MAYOR
    MAYORIGUAL
    MOD
    MOVE
    NOT
    NUMBER
    OR
    POP_VEC
    PRINT
    PUSH_VEC
    REF
    RETURN
    SELF
    SELFLOWERCASE
    STATIC
    SUPER
    TRAIT
    TYPE
    UNSAFE
    USE
    VECTOR
    WHERE
    WHILE

Grammar

Rule 0     S' -> rust
Rule 1     rust -> asignacion
Rule 2     rust -> prints
Rule 3     rust -> hashset
Rule 4     rust -> hashfunc
Rule 5     rust -> conditional
Rule 6     rust -> conditional_asigned
Rule 7     rust -> for_loop
Rule 8     rust -> struct_s
Rule 9     rust -> asig_mate
Rule 10    rust -> dec_slice
Rule 11    rust -> slice_get
Rule 12    rust -> slice_contains
Rule 13    asignacion -> declarador ASIGNAR expresion ENDLINE
Rule 14    asignacion -> other_operators ENDLINE
Rule 15    other_operators -> VARIABLE oper_asig expresion
Rule 16    declarador -> VARIABLE
Rule 17    declarador -> let_asig
Rule 18    let_asig -> LET var_tipo
Rule 19    let_asig -> LET MUT var_tipo
Rule 20    var_tipo -> VARIABLE
Rule 21    var_tipo -> VARIABLE ASIGNATION_TYPE tipos
Rule 22    tipos -> DATATYPES
Rule 23    tipos -> NUMDATATYPES
Rule 24    oper_asig -> ASIGNAR
Rule 25    oper_asig -> PLUSEQ
Rule 26    oper_asig -> MINUSEQ
Rule 27    oper_asig -> STAREQ
Rule 28    oper_asig -> SLASHEQ
Rule 29    expresion -> STRING
Rule 30    expresion -> U8
Rule 31    prints -> PRINTS LPAREN print_expresion RPAREN ENDLINE
Rule 32    print_expresion -> STRING
Rule 33    print_expresion -> STRING COMMA print_args
Rule 34    print_args -> print_datos COMMA print_args
Rule 35    print_args -> print_datos
Rule 36    print_datos -> expresion
Rule 37    hashset -> LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
Rule 38    hashfunc -> hashset_insert
Rule 39    hashfunc -> hashset_union
Rule 40    hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
Rule 41    hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
Rule 42    conditional_asigned -> declarador ASIGNAR conditional ENDLINE
Rule 43    conditional -> if_type validations LLAVEIZ rust LLAVEDER
Rule 44    if_type -> IF
Rule 45    if_type -> ELSE IF
Rule 46    if_type -> ELSE
Rule 47    validations -> comparison
Rule 48    validations -> comparison ANDAND validations
Rule 49    validations -> comparison OROR validations
Rule 50    comparison -> VARIABLE signo_comp VARIABLE
Rule 51    comparison -> VARIABLE signo_comp U8
Rule 52    comparison -> U8 signo_comp VARIABLE
Rule 53    signo_comp -> GREATER
Rule 54    signo_comp -> LESST
Rule 55    signo_comp -> GREATEQ
Rule 56    signo_comp -> EQUAL
Rule 57    signo_comp -> DIFFERENT
Rule 58    f_comparacion -> rango
Rule 59    f_comparacion -> VARIABLE
Rule 60    for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
Rule 61    struct_s -> STRUCT sent_stru
Rule 62    argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos
Rule 63    argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
Rule 64    argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
Rule 65    argumentos_tipo -> tipos
Rule 66    argumentos_tipo -> tipos COMMA argumentos_tipo
Rule 67    sent_stru -> UNIT ENDLINE
Rule 68    sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN ENDLINE
Rule 69    sent_stru -> VARIABLE LLAVEIZ argumentos_juntos LLAVEDER
Rule 70    asig_mate -> VARIABLE ASIGNAR op_mat ENDLINE
Rule 71    asig_mate -> LET VARIABLE ASIGNAR op_mat ENDLINE
Rule 72    asig_mate -> LET MUT VARIABLE ASIGNAR op_mat ENDLINE
Rule 73    op_mat -> art_exp
Rule 74    op_mat -> VARIABLE art_exp
Rule 75    op_mat -> U8 art_exp
Rule 76    art_exp -> VARIABLE signo_arit VARIABLE
Rule 77    art_exp -> U8 signo_arit VARIABLE
Rule 78    art_exp -> VARIABLE signo_arit U8
Rule 79    art_exp -> U8 signo_arit U8
Rule 80    signo_arit -> MAS
Rule 81    signo_arit -> MENOS
Rule 82    signo_arit -> MULT
Rule 83    signo_arit -> DIVISION
Rule 84    signo_arit -> MODULO
Rule 85    rango -> U8 DOT DOT U8
Rule 86    dec_slice -> LET VARIABLE ASIGNAR slice_exp ENDLINE
Rule 87    dec_slice -> LET MUT VARIABLE ASIGNAR slice_exp ENDLINE
Rule 88    slice_exp -> AND empty VARIABLE empty BRACKETL rango BRACKETR
Rule 89    slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
Rule 90    valor_get -> rango
Rule 91    valor_get -> U8
Rule 92    slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
Rule 93    empty -> <empty>

Terminals, with rules where they appear

AND                  : 41 88 92
ANDAND               : 48
ARROW                : 
AS                   : 
ASIGNAR              : 13 24 37 42 70 71 72 86 87
ASIGNATION_TYPE      : 21 62 63 64
ASYNC                : 
AWAIT                : 
BRACKETL             : 88
BRACKETR             : 88
BREAK                : 
B_FALSE              : 
B_TRUE               : 
COMMA                : 33 34 63 64 66
CONST                : 
CONTAINS_SLICE       : 92
CONTIN               : 
CRATE                : 
DATATYPES            : 22
DIFFERENT            : 57
DIVISION             : 83
DOLLAR               : 
DOT                  : 40 41 85 85 89 92
DOTDOTDOT            : 
DYN                  : 
ELSE                 : 45 46
ENDLINE              : 13 14 31 37 40 41 42 67 68 70 71 72 86 87
ENUM                 : 
EQUAL                : 56
ERRORPROP            : 
EXTERN               : 
FOR                  : 60
FUNCTION             : 
GET_SLICE            : 89
GREATEQ              : 55
GREATER              : 53
HASHSET              : 37
IF                   : 44 45
IMPL                 : 
IN                   : 60
INSERT_HASH          : 40
LESSEQ               : 
LESST                : 54
LET                  : 18 19 37 71 72 86 87
LLAVEDER             : 43 60 69
LLAVEIZ              : 43 60 69
LOOP                 : 
LPAREN               : 31 40 41 68 89 92
MAS                  : 80
MATCH                : 
MAYOR                : 
MAYORIGUAL           : 
MENOS                : 81
MINUSEQ              : 26
MOD                  : 
MODULO               : 84
MOVE                 : 
MULT                 : 82
MUT                  : 19 37 72 87
NEWFUNC              : 37
NOT                  : 
NUMBER               : 
NUMDATATYPES         : 23
OR                   : 
OROR                 : 49
PATHSEP              : 37
PLUSEQ               : 25
POP_VEC              : 
PRINT                : 
PRINTS               : 31
PUB                  : 64
PUSH_VEC             : 
REF                  : 
RETURN               : 
RPAREN               : 31 40 41 68 89 92
SELF                 : 
SELFLOWERCASE        : 
SLASHEQ              : 28
STAREQ               : 27
STATIC               : 
STRING               : 29 32 33
STRUCT               : 61
SUPER                : 
TRAIT                : 
TUPLE                : 68
TYPE                 : 
U8                   : 30 51 52 75 77 78 79 79 85 85 91 92
UNION_HASH           : 41
UNIT                 : 67
UNSAFE               : 
USE                  : 
VARIABLE             : 15 16 20 21 37 40 41 41 50 50 51 52 59 60 62 63 64 69 70 71 72 74 76 76 77 78 86 87 88 89 92
VECTOR               : 
WHERE                : 
WHILE                : 
error                : 

Nonterminals, with rules where they appear

argumentos_juntos    : 63 64 69
argumentos_tipo      : 66 68
art_exp              : 73 74 75
asig_mate            : 9
asignacion           : 1
comparison           : 47 48 49
conditional          : 5 42
conditional_asigned  : 6
dec_slice            : 10
declarador           : 13 42
empty                : 88 88 89 89 89 92 92 92
expresion            : 13 15 36 40
f_comparacion        : 60
for_loop             : 7
hashfunc             : 4
hashset              : 3
hashset_insert       : 38
hashset_union        : 39
if_type              : 43
let_asig             : 17
op_mat               : 70 71 72
oper_asig            : 15
other_operators      : 14
print_args           : 33 34
print_datos          : 34 35
print_expresion      : 31
prints               : 2
rango                : 58 88 90
rust                 : 43 60 0
sent_stru            : 61
signo_arit           : 76 77 78 79
signo_comp           : 50 51 52
slice_contains       : 12
slice_exp            : 86 87
slice_get            : 11
struct_s             : 8
tipos                : 21 62 63 64 65 66
validations          : 43 48 49
valor_get            : 89
var_tipo             : 18 19

Parsing method: LALR

state 0

    (0) S' -> . rust
    (1) rust -> . asignacion
    (2) rust -> . prints
    (3) rust -> . hashset
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . asig_mate
    (10) rust -> . dec_slice
    (11) rust -> . slice_get
    (12) rust -> . slice_contains
    (13) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (14) asignacion -> . other_operators ENDLINE
    (31) prints -> . PRINTS LPAREN print_expresion RPAREN ENDLINE
    (37) hashset -> . LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (38) hashfunc -> . hashset_insert
    (39) hashfunc -> . hashset_union
    (43) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (42) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (60) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (61) struct_s -> . STRUCT sent_stru
    (70) asig_mate -> . VARIABLE ASIGNAR op_mat ENDLINE
    (71) asig_mate -> . LET VARIABLE ASIGNAR op_mat ENDLINE
    (72) asig_mate -> . LET MUT VARIABLE ASIGNAR op_mat ENDLINE
    (86) dec_slice -> . LET VARIABLE ASIGNAR slice_exp ENDLINE
    (87) dec_slice -> . LET MUT VARIABLE ASIGNAR slice_exp ENDLINE
    (89) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (92) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (16) declarador -> . VARIABLE
    (17) declarador -> . let_asig
    (15) other_operators -> . VARIABLE oper_asig expresion
    (40) hashset_insert -> . VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (41) hashset_union -> . VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
    (44) if_type -> . IF
    (45) if_type -> . ELSE IF
    (46) if_type -> . ELSE
    (18) let_asig -> . LET var_tipo
    (19) let_asig -> . LET MUT var_tipo

    PRINTS          shift and go to state 16
    LET             shift and go to state 17
    FOR             shift and go to state 22
    STRUCT          shift and go to state 23
    VARIABLE        shift and go to state 18
    IF              shift and go to state 25
    ELSE            shift and go to state 26

    rust                           shift and go to state 1
    asignacion                     shift and go to state 2
    prints                         shift and go to state 3
    hashset                        shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    asig_mate                      shift and go to state 10
    dec_slice                      shift and go to state 11
    slice_get                      shift and go to state 12
    slice_contains                 shift and go to state 13
    declarador                     shift and go to state 14
    other_operators                shift and go to state 15
    hashset_insert                 shift and go to state 19
    hashset_union                  shift and go to state 20
    if_type                        shift and go to state 21
    let_asig                       shift and go to state 24

state 1

    (0) S' -> rust .



state 2

    (1) rust -> asignacion .

    $end            reduce using rule 1 (rust -> asignacion .)
    LLAVEDER        reduce using rule 1 (rust -> asignacion .)


state 3

    (2) rust -> prints .

    $end            reduce using rule 2 (rust -> prints .)
    LLAVEDER        reduce using rule 2 (rust -> prints .)


state 4

    (3) rust -> hashset .

    $end            reduce using rule 3 (rust -> hashset .)
    LLAVEDER        reduce using rule 3 (rust -> hashset .)


state 5

    (4) rust -> hashfunc .

    $end            reduce using rule 4 (rust -> hashfunc .)
    LLAVEDER        reduce using rule 4 (rust -> hashfunc .)


state 6

    (5) rust -> conditional .

    $end            reduce using rule 5 (rust -> conditional .)
    LLAVEDER        reduce using rule 5 (rust -> conditional .)


state 7

    (6) rust -> conditional_asigned .

    $end            reduce using rule 6 (rust -> conditional_asigned .)
    LLAVEDER        reduce using rule 6 (rust -> conditional_asigned .)


state 8

    (7) rust -> for_loop .

    $end            reduce using rule 7 (rust -> for_loop .)
    LLAVEDER        reduce using rule 7 (rust -> for_loop .)


state 9

    (8) rust -> struct_s .

    $end            reduce using rule 8 (rust -> struct_s .)
    LLAVEDER        reduce using rule 8 (rust -> struct_s .)


state 10

    (9) rust -> asig_mate .

    $end            reduce using rule 9 (rust -> asig_mate .)
    LLAVEDER        reduce using rule 9 (rust -> asig_mate .)


state 11

    (10) rust -> dec_slice .

    $end            reduce using rule 10 (rust -> dec_slice .)
    LLAVEDER        reduce using rule 10 (rust -> dec_slice .)


state 12

    (11) rust -> slice_get .

    $end            reduce using rule 11 (rust -> slice_get .)
    LLAVEDER        reduce using rule 11 (rust -> slice_get .)


state 13

    (12) rust -> slice_contains .

    $end            reduce using rule 12 (rust -> slice_contains .)
    LLAVEDER        reduce using rule 12 (rust -> slice_contains .)


state 14

    (13) asignacion -> declarador . ASIGNAR expresion ENDLINE
    (42) conditional_asigned -> declarador . ASIGNAR conditional ENDLINE

    ASIGNAR         shift and go to state 27


state 15

    (14) asignacion -> other_operators . ENDLINE

    ENDLINE         shift and go to state 28


state 16

    (31) prints -> PRINTS . LPAREN print_expresion RPAREN ENDLINE

    LPAREN          shift and go to state 29


state 17

    (37) hashset -> LET . MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (71) asig_mate -> LET . VARIABLE ASIGNAR op_mat ENDLINE
    (72) asig_mate -> LET . MUT VARIABLE ASIGNAR op_mat ENDLINE
    (86) dec_slice -> LET . VARIABLE ASIGNAR slice_exp ENDLINE
    (87) dec_slice -> LET . MUT VARIABLE ASIGNAR slice_exp ENDLINE
    (18) let_asig -> LET . var_tipo
    (19) let_asig -> LET . MUT var_tipo
    (20) var_tipo -> . VARIABLE
    (21) var_tipo -> . VARIABLE ASIGNATION_TYPE tipos

    MUT             shift and go to state 30
    VARIABLE        shift and go to state 31

    var_tipo                       shift and go to state 32

state 18

    (70) asig_mate -> VARIABLE . ASIGNAR op_mat ENDLINE
    (89) slice_get -> VARIABLE . empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (92) slice_contains -> VARIABLE . empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (16) declarador -> VARIABLE .
    (15) other_operators -> VARIABLE . oper_asig expresion
    (40) hashset_insert -> VARIABLE . DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (41) hashset_union -> VARIABLE . DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
    (93) empty -> .
    (24) oper_asig -> . ASIGNAR
    (25) oper_asig -> . PLUSEQ
    (26) oper_asig -> . MINUSEQ
    (27) oper_asig -> . STAREQ
    (28) oper_asig -> . SLASHEQ

  ! shift/reduce conflict for ASIGNAR resolved as shift
  ! shift/reduce conflict for DOT resolved as shift
    ASIGNAR         shift and go to state 33
    DOT             shift and go to state 35
    PLUSEQ          shift and go to state 37
    MINUSEQ         shift and go to state 38
    STAREQ          shift and go to state 39
    SLASHEQ         shift and go to state 40

  ! ASIGNAR         [ reduce using rule 16 (declarador -> VARIABLE .) ]
  ! DOT             [ reduce using rule 93 (empty -> .) ]

    empty                          shift and go to state 34
    oper_asig                      shift and go to state 36

state 19

    (38) hashfunc -> hashset_insert .

    $end            reduce using rule 38 (hashfunc -> hashset_insert .)
    LLAVEDER        reduce using rule 38 (hashfunc -> hashset_insert .)


state 20

    (39) hashfunc -> hashset_union .

    $end            reduce using rule 39 (hashfunc -> hashset_union .)
    LLAVEDER        reduce using rule 39 (hashfunc -> hashset_union .)


state 21

    (43) conditional -> if_type . validations LLAVEIZ rust LLAVEDER
    (47) validations -> . comparison
    (48) validations -> . comparison ANDAND validations
    (49) validations -> . comparison OROR validations
    (50) comparison -> . VARIABLE signo_comp VARIABLE
    (51) comparison -> . VARIABLE signo_comp U8
    (52) comparison -> . U8 signo_comp VARIABLE

    VARIABLE        shift and go to state 43
    U8              shift and go to state 44

    validations                    shift and go to state 41
    comparison                     shift and go to state 42

state 22

    (60) for_loop -> FOR . VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER

    VARIABLE        shift and go to state 45


state 23

    (61) struct_s -> STRUCT . sent_stru
    (67) sent_stru -> . UNIT ENDLINE
    (68) sent_stru -> . TUPLE LPAREN argumentos_tipo RPAREN ENDLINE
    (69) sent_stru -> . VARIABLE LLAVEIZ argumentos_juntos LLAVEDER

    UNIT            shift and go to state 47
    TUPLE           shift and go to state 48
    VARIABLE        shift and go to state 49

    sent_stru                      shift and go to state 46

state 24

    (17) declarador -> let_asig .

    ASIGNAR         reduce using rule 17 (declarador -> let_asig .)


state 25

    (44) if_type -> IF .

    VARIABLE        reduce using rule 44 (if_type -> IF .)
    U8              reduce using rule 44 (if_type -> IF .)


state 26

    (45) if_type -> ELSE . IF
    (46) if_type -> ELSE .

    IF              shift and go to state 50
    VARIABLE        reduce using rule 46 (if_type -> ELSE .)
    U8              reduce using rule 46 (if_type -> ELSE .)


state 27

    (13) asignacion -> declarador ASIGNAR . expresion ENDLINE
    (42) conditional_asigned -> declarador ASIGNAR . conditional ENDLINE
    (29) expresion -> . STRING
    (30) expresion -> . U8
    (43) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (44) if_type -> . IF
    (45) if_type -> . ELSE IF
    (46) if_type -> . ELSE

    STRING          shift and go to state 53
    U8              shift and go to state 54
    IF              shift and go to state 25
    ELSE            shift and go to state 26

    expresion                      shift and go to state 51
    conditional                    shift and go to state 52
    if_type                        shift and go to state 21

state 28

    (14) asignacion -> other_operators ENDLINE .

    $end            reduce using rule 14 (asignacion -> other_operators ENDLINE .)
    LLAVEDER        reduce using rule 14 (asignacion -> other_operators ENDLINE .)


state 29

    (31) prints -> PRINTS LPAREN . print_expresion RPAREN ENDLINE
    (32) print_expresion -> . STRING
    (33) print_expresion -> . STRING COMMA print_args

    STRING          shift and go to state 56

    print_expresion                shift and go to state 55

state 30

    (37) hashset -> LET MUT . VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (72) asig_mate -> LET MUT . VARIABLE ASIGNAR op_mat ENDLINE
    (87) dec_slice -> LET MUT . VARIABLE ASIGNAR slice_exp ENDLINE
    (19) let_asig -> LET MUT . var_tipo
    (20) var_tipo -> . VARIABLE
    (21) var_tipo -> . VARIABLE ASIGNATION_TYPE tipos

    VARIABLE        shift and go to state 57

    var_tipo                       shift and go to state 58

state 31

    (71) asig_mate -> LET VARIABLE . ASIGNAR op_mat ENDLINE
    (86) dec_slice -> LET VARIABLE . ASIGNAR slice_exp ENDLINE
    (20) var_tipo -> VARIABLE .
    (21) var_tipo -> VARIABLE . ASIGNATION_TYPE tipos

  ! shift/reduce conflict for ASIGNAR resolved as shift
    ASIGNAR         shift and go to state 59
    ASIGNATION_TYPE shift and go to state 60

  ! ASIGNAR         [ reduce using rule 20 (var_tipo -> VARIABLE .) ]


state 32

    (18) let_asig -> LET var_tipo .

    ASIGNAR         reduce using rule 18 (let_asig -> LET var_tipo .)


state 33

    (70) asig_mate -> VARIABLE ASIGNAR . op_mat ENDLINE
    (24) oper_asig -> ASIGNAR .
    (73) op_mat -> . art_exp
    (74) op_mat -> . VARIABLE art_exp
    (75) op_mat -> . U8 art_exp
    (76) art_exp -> . VARIABLE signo_arit VARIABLE
    (77) art_exp -> . U8 signo_arit VARIABLE
    (78) art_exp -> . VARIABLE signo_arit U8
    (79) art_exp -> . U8 signo_arit U8

  ! shift/reduce conflict for U8 resolved as shift
    STRING          reduce using rule 24 (oper_asig -> ASIGNAR .)
    VARIABLE        shift and go to state 61
    U8              shift and go to state 64

  ! U8              [ reduce using rule 24 (oper_asig -> ASIGNAR .) ]

    op_mat                         shift and go to state 62
    art_exp                        shift and go to state 63

state 34

    (89) slice_get -> VARIABLE empty . DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (92) slice_contains -> VARIABLE empty . DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN

    DOT             shift and go to state 65


state 35

    (40) hashset_insert -> VARIABLE DOT . INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (41) hashset_union -> VARIABLE DOT . UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE

    INSERT_HASH     shift and go to state 66
    UNION_HASH      shift and go to state 67


state 36

    (15) other_operators -> VARIABLE oper_asig . expresion
    (29) expresion -> . STRING
    (30) expresion -> . U8

    STRING          shift and go to state 53
    U8              shift and go to state 54

    expresion                      shift and go to state 68

state 37

    (25) oper_asig -> PLUSEQ .

    STRING          reduce using rule 25 (oper_asig -> PLUSEQ .)
    U8              reduce using rule 25 (oper_asig -> PLUSEQ .)


state 38

    (26) oper_asig -> MINUSEQ .

    STRING          reduce using rule 26 (oper_asig -> MINUSEQ .)
    U8              reduce using rule 26 (oper_asig -> MINUSEQ .)


state 39

    (27) oper_asig -> STAREQ .

    STRING          reduce using rule 27 (oper_asig -> STAREQ .)
    U8              reduce using rule 27 (oper_asig -> STAREQ .)


state 40

    (28) oper_asig -> SLASHEQ .

    STRING          reduce using rule 28 (oper_asig -> SLASHEQ .)
    U8              reduce using rule 28 (oper_asig -> SLASHEQ .)


state 41

    (43) conditional -> if_type validations . LLAVEIZ rust LLAVEDER

    LLAVEIZ         shift and go to state 69


state 42

    (47) validations -> comparison .
    (48) validations -> comparison . ANDAND validations
    (49) validations -> comparison . OROR validations

    LLAVEIZ         reduce using rule 47 (validations -> comparison .)
    ANDAND          shift and go to state 70
    OROR            shift and go to state 71


state 43

    (50) comparison -> VARIABLE . signo_comp VARIABLE
    (51) comparison -> VARIABLE . signo_comp U8
    (53) signo_comp -> . GREATER
    (54) signo_comp -> . LESST
    (55) signo_comp -> . GREATEQ
    (56) signo_comp -> . EQUAL
    (57) signo_comp -> . DIFFERENT

    GREATER         shift and go to state 73
    LESST           shift and go to state 74
    GREATEQ         shift and go to state 75
    EQUAL           shift and go to state 76
    DIFFERENT       shift and go to state 77

    signo_comp                     shift and go to state 72

state 44

    (52) comparison -> U8 . signo_comp VARIABLE
    (53) signo_comp -> . GREATER
    (54) signo_comp -> . LESST
    (55) signo_comp -> . GREATEQ
    (56) signo_comp -> . EQUAL
    (57) signo_comp -> . DIFFERENT

    GREATER         shift and go to state 73
    LESST           shift and go to state 74
    GREATEQ         shift and go to state 75
    EQUAL           shift and go to state 76
    DIFFERENT       shift and go to state 77

    signo_comp                     shift and go to state 78

state 45

    (60) for_loop -> FOR VARIABLE . IN f_comparacion LLAVEIZ rust LLAVEDER

    IN              shift and go to state 79


state 46

    (61) struct_s -> STRUCT sent_stru .

    $end            reduce using rule 61 (struct_s -> STRUCT sent_stru .)
    LLAVEDER        reduce using rule 61 (struct_s -> STRUCT sent_stru .)


state 47

    (67) sent_stru -> UNIT . ENDLINE

    ENDLINE         shift and go to state 80


state 48

    (68) sent_stru -> TUPLE . LPAREN argumentos_tipo RPAREN ENDLINE

    LPAREN          shift and go to state 81


state 49

    (69) sent_stru -> VARIABLE . LLAVEIZ argumentos_juntos LLAVEDER

    LLAVEIZ         shift and go to state 82


state 50

    (45) if_type -> ELSE IF .

    VARIABLE        reduce using rule 45 (if_type -> ELSE IF .)
    U8              reduce using rule 45 (if_type -> ELSE IF .)


state 51

    (13) asignacion -> declarador ASIGNAR expresion . ENDLINE

    ENDLINE         shift and go to state 83


state 52

    (42) conditional_asigned -> declarador ASIGNAR conditional . ENDLINE

    ENDLINE         shift and go to state 84


state 53

    (29) expresion -> STRING .

    ENDLINE         reduce using rule 29 (expresion -> STRING .)
    COMMA           reduce using rule 29 (expresion -> STRING .)
    RPAREN          reduce using rule 29 (expresion -> STRING .)


state 54

    (30) expresion -> U8 .

    ENDLINE         reduce using rule 30 (expresion -> U8 .)
    COMMA           reduce using rule 30 (expresion -> U8 .)
    RPAREN          reduce using rule 30 (expresion -> U8 .)


state 55

    (31) prints -> PRINTS LPAREN print_expresion . RPAREN ENDLINE

    RPAREN          shift and go to state 85


state 56

    (32) print_expresion -> STRING .
    (33) print_expresion -> STRING . COMMA print_args

    RPAREN          reduce using rule 32 (print_expresion -> STRING .)
    COMMA           shift and go to state 86


state 57

    (37) hashset -> LET MUT VARIABLE . ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (72) asig_mate -> LET MUT VARIABLE . ASIGNAR op_mat ENDLINE
    (87) dec_slice -> LET MUT VARIABLE . ASIGNAR slice_exp ENDLINE
    (20) var_tipo -> VARIABLE .
    (21) var_tipo -> VARIABLE . ASIGNATION_TYPE tipos

  ! shift/reduce conflict for ASIGNAR resolved as shift
    ASIGNAR         shift and go to state 87
    ASIGNATION_TYPE shift and go to state 60

  ! ASIGNAR         [ reduce using rule 20 (var_tipo -> VARIABLE .) ]


state 58

    (19) let_asig -> LET MUT var_tipo .

    ASIGNAR         reduce using rule 19 (let_asig -> LET MUT var_tipo .)


state 59

    (71) asig_mate -> LET VARIABLE ASIGNAR . op_mat ENDLINE
    (86) dec_slice -> LET VARIABLE ASIGNAR . slice_exp ENDLINE
    (73) op_mat -> . art_exp
    (74) op_mat -> . VARIABLE art_exp
    (75) op_mat -> . U8 art_exp
    (88) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (76) art_exp -> . VARIABLE signo_arit VARIABLE
    (77) art_exp -> . U8 signo_arit VARIABLE
    (78) art_exp -> . VARIABLE signo_arit U8
    (79) art_exp -> . U8 signo_arit U8

    VARIABLE        shift and go to state 61
    U8              shift and go to state 64
    AND             shift and go to state 90

    op_mat                         shift and go to state 88
    slice_exp                      shift and go to state 89
    art_exp                        shift and go to state 63

state 60

    (21) var_tipo -> VARIABLE ASIGNATION_TYPE . tipos
    (22) tipos -> . DATATYPES
    (23) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 92
    NUMDATATYPES    shift and go to state 93

    tipos                          shift and go to state 91

state 61

    (74) op_mat -> VARIABLE . art_exp
    (76) art_exp -> VARIABLE . signo_arit VARIABLE
    (78) art_exp -> VARIABLE . signo_arit U8
    (76) art_exp -> . VARIABLE signo_arit VARIABLE
    (77) art_exp -> . U8 signo_arit VARIABLE
    (78) art_exp -> . VARIABLE signo_arit U8
    (79) art_exp -> . U8 signo_arit U8
    (80) signo_arit -> . MAS
    (81) signo_arit -> . MENOS
    (82) signo_arit -> . MULT
    (83) signo_arit -> . DIVISION
    (84) signo_arit -> . MODULO

    VARIABLE        shift and go to state 94
    U8              shift and go to state 97
    MAS             shift and go to state 98
    MENOS           shift and go to state 99
    MULT            shift and go to state 100
    DIVISION        shift and go to state 101
    MODULO          shift and go to state 102

    art_exp                        shift and go to state 95
    signo_arit                     shift and go to state 96

state 62

    (70) asig_mate -> VARIABLE ASIGNAR op_mat . ENDLINE

    ENDLINE         shift and go to state 103


state 63

    (73) op_mat -> art_exp .

    ENDLINE         reduce using rule 73 (op_mat -> art_exp .)


state 64

    (75) op_mat -> U8 . art_exp
    (77) art_exp -> U8 . signo_arit VARIABLE
    (79) art_exp -> U8 . signo_arit U8
    (76) art_exp -> . VARIABLE signo_arit VARIABLE
    (77) art_exp -> . U8 signo_arit VARIABLE
    (78) art_exp -> . VARIABLE signo_arit U8
    (79) art_exp -> . U8 signo_arit U8
    (80) signo_arit -> . MAS
    (81) signo_arit -> . MENOS
    (82) signo_arit -> . MULT
    (83) signo_arit -> . DIVISION
    (84) signo_arit -> . MODULO

    VARIABLE        shift and go to state 94
    U8              shift and go to state 97
    MAS             shift and go to state 98
    MENOS           shift and go to state 99
    MULT            shift and go to state 100
    DIVISION        shift and go to state 101
    MODULO          shift and go to state 102

    art_exp                        shift and go to state 104
    signo_arit                     shift and go to state 105

state 65

    (89) slice_get -> VARIABLE empty DOT . empty GET_SLICE empty LPAREN valor_get RPAREN
    (92) slice_contains -> VARIABLE empty DOT . empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (93) empty -> .

    GET_SLICE       reduce using rule 93 (empty -> .)
    CONTAINS_SLICE  reduce using rule 93 (empty -> .)

    empty                          shift and go to state 106

state 66

    (40) hashset_insert -> VARIABLE DOT INSERT_HASH . LPAREN expresion RPAREN ENDLINE

    LPAREN          shift and go to state 107


state 67

    (41) hashset_union -> VARIABLE DOT UNION_HASH . LPAREN AND VARIABLE RPAREN ENDLINE

    LPAREN          shift and go to state 108


state 68

    (15) other_operators -> VARIABLE oper_asig expresion .

    ENDLINE         reduce using rule 15 (other_operators -> VARIABLE oper_asig expresion .)


state 69

    (43) conditional -> if_type validations LLAVEIZ . rust LLAVEDER
    (1) rust -> . asignacion
    (2) rust -> . prints
    (3) rust -> . hashset
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . asig_mate
    (10) rust -> . dec_slice
    (11) rust -> . slice_get
    (12) rust -> . slice_contains
    (13) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (14) asignacion -> . other_operators ENDLINE
    (31) prints -> . PRINTS LPAREN print_expresion RPAREN ENDLINE
    (37) hashset -> . LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (38) hashfunc -> . hashset_insert
    (39) hashfunc -> . hashset_union
    (43) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (42) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (60) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (61) struct_s -> . STRUCT sent_stru
    (70) asig_mate -> . VARIABLE ASIGNAR op_mat ENDLINE
    (71) asig_mate -> . LET VARIABLE ASIGNAR op_mat ENDLINE
    (72) asig_mate -> . LET MUT VARIABLE ASIGNAR op_mat ENDLINE
    (86) dec_slice -> . LET VARIABLE ASIGNAR slice_exp ENDLINE
    (87) dec_slice -> . LET MUT VARIABLE ASIGNAR slice_exp ENDLINE
    (89) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (92) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (16) declarador -> . VARIABLE
    (17) declarador -> . let_asig
    (15) other_operators -> . VARIABLE oper_asig expresion
    (40) hashset_insert -> . VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (41) hashset_union -> . VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
    (44) if_type -> . IF
    (45) if_type -> . ELSE IF
    (46) if_type -> . ELSE
    (18) let_asig -> . LET var_tipo
    (19) let_asig -> . LET MUT var_tipo

    PRINTS          shift and go to state 16
    LET             shift and go to state 17
    FOR             shift and go to state 22
    STRUCT          shift and go to state 23
    VARIABLE        shift and go to state 18
    IF              shift and go to state 25
    ELSE            shift and go to state 26

    if_type                        shift and go to state 21
    rust                           shift and go to state 109
    asignacion                     shift and go to state 2
    prints                         shift and go to state 3
    hashset                        shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    asig_mate                      shift and go to state 10
    dec_slice                      shift and go to state 11
    slice_get                      shift and go to state 12
    slice_contains                 shift and go to state 13
    declarador                     shift and go to state 14
    other_operators                shift and go to state 15
    hashset_insert                 shift and go to state 19
    hashset_union                  shift and go to state 20
    let_asig                       shift and go to state 24

state 70

    (48) validations -> comparison ANDAND . validations
    (47) validations -> . comparison
    (48) validations -> . comparison ANDAND validations
    (49) validations -> . comparison OROR validations
    (50) comparison -> . VARIABLE signo_comp VARIABLE
    (51) comparison -> . VARIABLE signo_comp U8
    (52) comparison -> . U8 signo_comp VARIABLE

    VARIABLE        shift and go to state 43
    U8              shift and go to state 44

    comparison                     shift and go to state 42
    validations                    shift and go to state 110

state 71

    (49) validations -> comparison OROR . validations
    (47) validations -> . comparison
    (48) validations -> . comparison ANDAND validations
    (49) validations -> . comparison OROR validations
    (50) comparison -> . VARIABLE signo_comp VARIABLE
    (51) comparison -> . VARIABLE signo_comp U8
    (52) comparison -> . U8 signo_comp VARIABLE

    VARIABLE        shift and go to state 43
    U8              shift and go to state 44

    comparison                     shift and go to state 42
    validations                    shift and go to state 111

state 72

    (50) comparison -> VARIABLE signo_comp . VARIABLE
    (51) comparison -> VARIABLE signo_comp . U8

    VARIABLE        shift and go to state 112
    U8              shift and go to state 113


state 73

    (53) signo_comp -> GREATER .

    VARIABLE        reduce using rule 53 (signo_comp -> GREATER .)
    U8              reduce using rule 53 (signo_comp -> GREATER .)


state 74

    (54) signo_comp -> LESST .

    VARIABLE        reduce using rule 54 (signo_comp -> LESST .)
    U8              reduce using rule 54 (signo_comp -> LESST .)


state 75

    (55) signo_comp -> GREATEQ .

    VARIABLE        reduce using rule 55 (signo_comp -> GREATEQ .)
    U8              reduce using rule 55 (signo_comp -> GREATEQ .)


state 76

    (56) signo_comp -> EQUAL .

    VARIABLE        reduce using rule 56 (signo_comp -> EQUAL .)
    U8              reduce using rule 56 (signo_comp -> EQUAL .)


state 77

    (57) signo_comp -> DIFFERENT .

    VARIABLE        reduce using rule 57 (signo_comp -> DIFFERENT .)
    U8              reduce using rule 57 (signo_comp -> DIFFERENT .)


state 78

    (52) comparison -> U8 signo_comp . VARIABLE

    VARIABLE        shift and go to state 114


state 79

    (60) for_loop -> FOR VARIABLE IN . f_comparacion LLAVEIZ rust LLAVEDER
    (58) f_comparacion -> . rango
    (59) f_comparacion -> . VARIABLE
    (85) rango -> . U8 DOT DOT U8

    VARIABLE        shift and go to state 115
    U8              shift and go to state 118

    f_comparacion                  shift and go to state 116
    rango                          shift and go to state 117

state 80

    (67) sent_stru -> UNIT ENDLINE .

    $end            reduce using rule 67 (sent_stru -> UNIT ENDLINE .)
    LLAVEDER        reduce using rule 67 (sent_stru -> UNIT ENDLINE .)


state 81

    (68) sent_stru -> TUPLE LPAREN . argumentos_tipo RPAREN ENDLINE
    (65) argumentos_tipo -> . tipos
    (66) argumentos_tipo -> . tipos COMMA argumentos_tipo
    (22) tipos -> . DATATYPES
    (23) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 92
    NUMDATATYPES    shift and go to state 93

    argumentos_tipo                shift and go to state 119
    tipos                          shift and go to state 120

state 82

    (69) sent_stru -> VARIABLE LLAVEIZ . argumentos_juntos LLAVEDER
    (62) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos
    (63) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
    (64) argumentos_juntos -> . PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos

    VARIABLE        shift and go to state 121
    PUB             shift and go to state 123

    argumentos_juntos              shift and go to state 122

state 83

    (13) asignacion -> declarador ASIGNAR expresion ENDLINE .

    $end            reduce using rule 13 (asignacion -> declarador ASIGNAR expresion ENDLINE .)
    LLAVEDER        reduce using rule 13 (asignacion -> declarador ASIGNAR expresion ENDLINE .)


state 84

    (42) conditional_asigned -> declarador ASIGNAR conditional ENDLINE .

    $end            reduce using rule 42 (conditional_asigned -> declarador ASIGNAR conditional ENDLINE .)
    LLAVEDER        reduce using rule 42 (conditional_asigned -> declarador ASIGNAR conditional ENDLINE .)


state 85

    (31) prints -> PRINTS LPAREN print_expresion RPAREN . ENDLINE

    ENDLINE         shift and go to state 124


state 86

    (33) print_expresion -> STRING COMMA . print_args
    (34) print_args -> . print_datos COMMA print_args
    (35) print_args -> . print_datos
    (36) print_datos -> . expresion
    (29) expresion -> . STRING
    (30) expresion -> . U8

    STRING          shift and go to state 53
    U8              shift and go to state 54

    print_args                     shift and go to state 125
    print_datos                    shift and go to state 126
    expresion                      shift and go to state 127

state 87

    (37) hashset -> LET MUT VARIABLE ASIGNAR . HASHSET PATHSEP NEWFUNC ENDLINE
    (72) asig_mate -> LET MUT VARIABLE ASIGNAR . op_mat ENDLINE
    (87) dec_slice -> LET MUT VARIABLE ASIGNAR . slice_exp ENDLINE
    (73) op_mat -> . art_exp
    (74) op_mat -> . VARIABLE art_exp
    (75) op_mat -> . U8 art_exp
    (88) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (76) art_exp -> . VARIABLE signo_arit VARIABLE
    (77) art_exp -> . U8 signo_arit VARIABLE
    (78) art_exp -> . VARIABLE signo_arit U8
    (79) art_exp -> . U8 signo_arit U8

    HASHSET         shift and go to state 128
    VARIABLE        shift and go to state 61
    U8              shift and go to state 64
    AND             shift and go to state 90

    op_mat                         shift and go to state 129
    slice_exp                      shift and go to state 130
    art_exp                        shift and go to state 63

state 88

    (71) asig_mate -> LET VARIABLE ASIGNAR op_mat . ENDLINE

    ENDLINE         shift and go to state 131


state 89

    (86) dec_slice -> LET VARIABLE ASIGNAR slice_exp . ENDLINE

    ENDLINE         shift and go to state 132


state 90

    (88) slice_exp -> AND . empty VARIABLE empty BRACKETL rango BRACKETR
    (93) empty -> .

    VARIABLE        reduce using rule 93 (empty -> .)

    empty                          shift and go to state 133

state 91

    (21) var_tipo -> VARIABLE ASIGNATION_TYPE tipos .

    ASIGNAR         reduce using rule 21 (var_tipo -> VARIABLE ASIGNATION_TYPE tipos .)


state 92

    (22) tipos -> DATATYPES .

    ASIGNAR         reduce using rule 22 (tipos -> DATATYPES .)
    COMMA           reduce using rule 22 (tipos -> DATATYPES .)
    RPAREN          reduce using rule 22 (tipos -> DATATYPES .)
    LLAVEDER        reduce using rule 22 (tipos -> DATATYPES .)


state 93

    (23) tipos -> NUMDATATYPES .

    ASIGNAR         reduce using rule 23 (tipos -> NUMDATATYPES .)
    COMMA           reduce using rule 23 (tipos -> NUMDATATYPES .)
    RPAREN          reduce using rule 23 (tipos -> NUMDATATYPES .)
    LLAVEDER        reduce using rule 23 (tipos -> NUMDATATYPES .)


state 94

    (76) art_exp -> VARIABLE . signo_arit VARIABLE
    (78) art_exp -> VARIABLE . signo_arit U8
    (80) signo_arit -> . MAS
    (81) signo_arit -> . MENOS
    (82) signo_arit -> . MULT
    (83) signo_arit -> . DIVISION
    (84) signo_arit -> . MODULO

    MAS             shift and go to state 98
    MENOS           shift and go to state 99
    MULT            shift and go to state 100
    DIVISION        shift and go to state 101
    MODULO          shift and go to state 102

    signo_arit                     shift and go to state 96

state 95

    (74) op_mat -> VARIABLE art_exp .

    ENDLINE         reduce using rule 74 (op_mat -> VARIABLE art_exp .)


state 96

    (76) art_exp -> VARIABLE signo_arit . VARIABLE
    (78) art_exp -> VARIABLE signo_arit . U8

    VARIABLE        shift and go to state 134
    U8              shift and go to state 135


state 97

    (77) art_exp -> U8 . signo_arit VARIABLE
    (79) art_exp -> U8 . signo_arit U8
    (80) signo_arit -> . MAS
    (81) signo_arit -> . MENOS
    (82) signo_arit -> . MULT
    (83) signo_arit -> . DIVISION
    (84) signo_arit -> . MODULO

    MAS             shift and go to state 98
    MENOS           shift and go to state 99
    MULT            shift and go to state 100
    DIVISION        shift and go to state 101
    MODULO          shift and go to state 102

    signo_arit                     shift and go to state 105

state 98

    (80) signo_arit -> MAS .

    VARIABLE        reduce using rule 80 (signo_arit -> MAS .)
    U8              reduce using rule 80 (signo_arit -> MAS .)


state 99

    (81) signo_arit -> MENOS .

    VARIABLE        reduce using rule 81 (signo_arit -> MENOS .)
    U8              reduce using rule 81 (signo_arit -> MENOS .)


state 100

    (82) signo_arit -> MULT .

    VARIABLE        reduce using rule 82 (signo_arit -> MULT .)
    U8              reduce using rule 82 (signo_arit -> MULT .)


state 101

    (83) signo_arit -> DIVISION .

    VARIABLE        reduce using rule 83 (signo_arit -> DIVISION .)
    U8              reduce using rule 83 (signo_arit -> DIVISION .)


state 102

    (84) signo_arit -> MODULO .

    VARIABLE        reduce using rule 84 (signo_arit -> MODULO .)
    U8              reduce using rule 84 (signo_arit -> MODULO .)


state 103

    (70) asig_mate -> VARIABLE ASIGNAR op_mat ENDLINE .

    $end            reduce using rule 70 (asig_mate -> VARIABLE ASIGNAR op_mat ENDLINE .)
    LLAVEDER        reduce using rule 70 (asig_mate -> VARIABLE ASIGNAR op_mat ENDLINE .)


state 104

    (75) op_mat -> U8 art_exp .

    ENDLINE         reduce using rule 75 (op_mat -> U8 art_exp .)


state 105

    (77) art_exp -> U8 signo_arit . VARIABLE
    (79) art_exp -> U8 signo_arit . U8

    VARIABLE        shift and go to state 137
    U8              shift and go to state 136


state 106

    (89) slice_get -> VARIABLE empty DOT empty . GET_SLICE empty LPAREN valor_get RPAREN
    (92) slice_contains -> VARIABLE empty DOT empty . CONTAINS_SLICE empty LPAREN AND U8 RPAREN

    GET_SLICE       shift and go to state 138
    CONTAINS_SLICE  shift and go to state 139


state 107

    (40) hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN . expresion RPAREN ENDLINE
    (29) expresion -> . STRING
    (30) expresion -> . U8

    STRING          shift and go to state 53
    U8              shift and go to state 54

    expresion                      shift and go to state 140

state 108

    (41) hashset_union -> VARIABLE DOT UNION_HASH LPAREN . AND VARIABLE RPAREN ENDLINE

    AND             shift and go to state 141


state 109

    (43) conditional -> if_type validations LLAVEIZ rust . LLAVEDER

    LLAVEDER        shift and go to state 142


state 110

    (48) validations -> comparison ANDAND validations .

    LLAVEIZ         reduce using rule 48 (validations -> comparison ANDAND validations .)


state 111

    (49) validations -> comparison OROR validations .

    LLAVEIZ         reduce using rule 49 (validations -> comparison OROR validations .)


state 112

    (50) comparison -> VARIABLE signo_comp VARIABLE .

    ANDAND          reduce using rule 50 (comparison -> VARIABLE signo_comp VARIABLE .)
    OROR            reduce using rule 50 (comparison -> VARIABLE signo_comp VARIABLE .)
    LLAVEIZ         reduce using rule 50 (comparison -> VARIABLE signo_comp VARIABLE .)


state 113

    (51) comparison -> VARIABLE signo_comp U8 .

    ANDAND          reduce using rule 51 (comparison -> VARIABLE signo_comp U8 .)
    OROR            reduce using rule 51 (comparison -> VARIABLE signo_comp U8 .)
    LLAVEIZ         reduce using rule 51 (comparison -> VARIABLE signo_comp U8 .)


state 114

    (52) comparison -> U8 signo_comp VARIABLE .

    ANDAND          reduce using rule 52 (comparison -> U8 signo_comp VARIABLE .)
    OROR            reduce using rule 52 (comparison -> U8 signo_comp VARIABLE .)
    LLAVEIZ         reduce using rule 52 (comparison -> U8 signo_comp VARIABLE .)


state 115

    (59) f_comparacion -> VARIABLE .

    LLAVEIZ         reduce using rule 59 (f_comparacion -> VARIABLE .)


state 116

    (60) for_loop -> FOR VARIABLE IN f_comparacion . LLAVEIZ rust LLAVEDER

    LLAVEIZ         shift and go to state 143


state 117

    (58) f_comparacion -> rango .

    LLAVEIZ         reduce using rule 58 (f_comparacion -> rango .)


state 118

    (85) rango -> U8 . DOT DOT U8

    DOT             shift and go to state 144


state 119

    (68) sent_stru -> TUPLE LPAREN argumentos_tipo . RPAREN ENDLINE

    RPAREN          shift and go to state 145


state 120

    (65) argumentos_tipo -> tipos .
    (66) argumentos_tipo -> tipos . COMMA argumentos_tipo

    RPAREN          reduce using rule 65 (argumentos_tipo -> tipos .)
    COMMA           shift and go to state 146


state 121

    (62) argumentos_juntos -> VARIABLE . ASIGNATION_TYPE tipos
    (63) argumentos_juntos -> VARIABLE . ASIGNATION_TYPE tipos COMMA argumentos_juntos

    ASIGNATION_TYPE shift and go to state 147


state 122

    (69) sent_stru -> VARIABLE LLAVEIZ argumentos_juntos . LLAVEDER

    LLAVEDER        shift and go to state 148


state 123

    (64) argumentos_juntos -> PUB . VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos

    VARIABLE        shift and go to state 149


state 124

    (31) prints -> PRINTS LPAREN print_expresion RPAREN ENDLINE .

    $end            reduce using rule 31 (prints -> PRINTS LPAREN print_expresion RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 31 (prints -> PRINTS LPAREN print_expresion RPAREN ENDLINE .)


state 125

    (33) print_expresion -> STRING COMMA print_args .

    RPAREN          reduce using rule 33 (print_expresion -> STRING COMMA print_args .)


state 126

    (34) print_args -> print_datos . COMMA print_args
    (35) print_args -> print_datos .

    COMMA           shift and go to state 150
    RPAREN          reduce using rule 35 (print_args -> print_datos .)


state 127

    (36) print_datos -> expresion .

    COMMA           reduce using rule 36 (print_datos -> expresion .)
    RPAREN          reduce using rule 36 (print_datos -> expresion .)


state 128

    (37) hashset -> LET MUT VARIABLE ASIGNAR HASHSET . PATHSEP NEWFUNC ENDLINE

    PATHSEP         shift and go to state 151


state 129

    (72) asig_mate -> LET MUT VARIABLE ASIGNAR op_mat . ENDLINE

    ENDLINE         shift and go to state 152


state 130

    (87) dec_slice -> LET MUT VARIABLE ASIGNAR slice_exp . ENDLINE

    ENDLINE         shift and go to state 153


state 131

    (71) asig_mate -> LET VARIABLE ASIGNAR op_mat ENDLINE .

    $end            reduce using rule 71 (asig_mate -> LET VARIABLE ASIGNAR op_mat ENDLINE .)
    LLAVEDER        reduce using rule 71 (asig_mate -> LET VARIABLE ASIGNAR op_mat ENDLINE .)


state 132

    (86) dec_slice -> LET VARIABLE ASIGNAR slice_exp ENDLINE .

    $end            reduce using rule 86 (dec_slice -> LET VARIABLE ASIGNAR slice_exp ENDLINE .)
    LLAVEDER        reduce using rule 86 (dec_slice -> LET VARIABLE ASIGNAR slice_exp ENDLINE .)


state 133

    (88) slice_exp -> AND empty . VARIABLE empty BRACKETL rango BRACKETR

    VARIABLE        shift and go to state 154


state 134

    (76) art_exp -> VARIABLE signo_arit VARIABLE .

    ENDLINE         reduce using rule 76 (art_exp -> VARIABLE signo_arit VARIABLE .)


state 135

    (78) art_exp -> VARIABLE signo_arit U8 .

    ENDLINE         reduce using rule 78 (art_exp -> VARIABLE signo_arit U8 .)


state 136

    (79) art_exp -> U8 signo_arit U8 .

    ENDLINE         reduce using rule 79 (art_exp -> U8 signo_arit U8 .)


state 137

    (77) art_exp -> U8 signo_arit VARIABLE .

    ENDLINE         reduce using rule 77 (art_exp -> U8 signo_arit VARIABLE .)


state 138

    (89) slice_get -> VARIABLE empty DOT empty GET_SLICE . empty LPAREN valor_get RPAREN
    (93) empty -> .

    LPAREN          reduce using rule 93 (empty -> .)

    empty                          shift and go to state 155

state 139

    (92) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE . empty LPAREN AND U8 RPAREN
    (93) empty -> .

    LPAREN          reduce using rule 93 (empty -> .)

    empty                          shift and go to state 156

state 140

    (40) hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN expresion . RPAREN ENDLINE

    RPAREN          shift and go to state 157


state 141

    (41) hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND . VARIABLE RPAREN ENDLINE

    VARIABLE        shift and go to state 158


state 142

    (43) conditional -> if_type validations LLAVEIZ rust LLAVEDER .

    $end            reduce using rule 43 (conditional -> if_type validations LLAVEIZ rust LLAVEDER .)
    ENDLINE         reduce using rule 43 (conditional -> if_type validations LLAVEIZ rust LLAVEDER .)
    LLAVEDER        reduce using rule 43 (conditional -> if_type validations LLAVEIZ rust LLAVEDER .)


state 143

    (60) for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ . rust LLAVEDER
    (1) rust -> . asignacion
    (2) rust -> . prints
    (3) rust -> . hashset
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . asig_mate
    (10) rust -> . dec_slice
    (11) rust -> . slice_get
    (12) rust -> . slice_contains
    (13) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (14) asignacion -> . other_operators ENDLINE
    (31) prints -> . PRINTS LPAREN print_expresion RPAREN ENDLINE
    (37) hashset -> . LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE
    (38) hashfunc -> . hashset_insert
    (39) hashfunc -> . hashset_union
    (43) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (42) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (60) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (61) struct_s -> . STRUCT sent_stru
    (70) asig_mate -> . VARIABLE ASIGNAR op_mat ENDLINE
    (71) asig_mate -> . LET VARIABLE ASIGNAR op_mat ENDLINE
    (72) asig_mate -> . LET MUT VARIABLE ASIGNAR op_mat ENDLINE
    (86) dec_slice -> . LET VARIABLE ASIGNAR slice_exp ENDLINE
    (87) dec_slice -> . LET MUT VARIABLE ASIGNAR slice_exp ENDLINE
    (89) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (92) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (16) declarador -> . VARIABLE
    (17) declarador -> . let_asig
    (15) other_operators -> . VARIABLE oper_asig expresion
    (40) hashset_insert -> . VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE
    (41) hashset_union -> . VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE
    (44) if_type -> . IF
    (45) if_type -> . ELSE IF
    (46) if_type -> . ELSE
    (18) let_asig -> . LET var_tipo
    (19) let_asig -> . LET MUT var_tipo

    PRINTS          shift and go to state 16
    LET             shift and go to state 17
    FOR             shift and go to state 22
    STRUCT          shift and go to state 23
    VARIABLE        shift and go to state 18
    IF              shift and go to state 25
    ELSE            shift and go to state 26

    rust                           shift and go to state 159
    asignacion                     shift and go to state 2
    prints                         shift and go to state 3
    hashset                        shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    asig_mate                      shift and go to state 10
    dec_slice                      shift and go to state 11
    slice_get                      shift and go to state 12
    slice_contains                 shift and go to state 13
    declarador                     shift and go to state 14
    other_operators                shift and go to state 15
    hashset_insert                 shift and go to state 19
    hashset_union                  shift and go to state 20
    if_type                        shift and go to state 21
    let_asig                       shift and go to state 24

state 144

    (85) rango -> U8 DOT . DOT U8

    DOT             shift and go to state 160


state 145

    (68) sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN . ENDLINE

    ENDLINE         shift and go to state 161


state 146

    (66) argumentos_tipo -> tipos COMMA . argumentos_tipo
    (65) argumentos_tipo -> . tipos
    (66) argumentos_tipo -> . tipos COMMA argumentos_tipo
    (22) tipos -> . DATATYPES
    (23) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 92
    NUMDATATYPES    shift and go to state 93

    tipos                          shift and go to state 120
    argumentos_tipo                shift and go to state 162

state 147

    (62) argumentos_juntos -> VARIABLE ASIGNATION_TYPE . tipos
    (63) argumentos_juntos -> VARIABLE ASIGNATION_TYPE . tipos COMMA argumentos_juntos
    (22) tipos -> . DATATYPES
    (23) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 92
    NUMDATATYPES    shift and go to state 93

    tipos                          shift and go to state 163

state 148

    (69) sent_stru -> VARIABLE LLAVEIZ argumentos_juntos LLAVEDER .

    $end            reduce using rule 69 (sent_stru -> VARIABLE LLAVEIZ argumentos_juntos LLAVEDER .)
    LLAVEDER        reduce using rule 69 (sent_stru -> VARIABLE LLAVEIZ argumentos_juntos LLAVEDER .)


state 149

    (64) argumentos_juntos -> PUB VARIABLE . ASIGNATION_TYPE tipos COMMA argumentos_juntos

    ASIGNATION_TYPE shift and go to state 164


state 150

    (34) print_args -> print_datos COMMA . print_args
    (34) print_args -> . print_datos COMMA print_args
    (35) print_args -> . print_datos
    (36) print_datos -> . expresion
    (29) expresion -> . STRING
    (30) expresion -> . U8

    STRING          shift and go to state 53
    U8              shift and go to state 54

    print_datos                    shift and go to state 126
    print_args                     shift and go to state 165
    expresion                      shift and go to state 127

state 151

    (37) hashset -> LET MUT VARIABLE ASIGNAR HASHSET PATHSEP . NEWFUNC ENDLINE

    NEWFUNC         shift and go to state 166


state 152

    (72) asig_mate -> LET MUT VARIABLE ASIGNAR op_mat ENDLINE .

    $end            reduce using rule 72 (asig_mate -> LET MUT VARIABLE ASIGNAR op_mat ENDLINE .)
    LLAVEDER        reduce using rule 72 (asig_mate -> LET MUT VARIABLE ASIGNAR op_mat ENDLINE .)


state 153

    (87) dec_slice -> LET MUT VARIABLE ASIGNAR slice_exp ENDLINE .

    $end            reduce using rule 87 (dec_slice -> LET MUT VARIABLE ASIGNAR slice_exp ENDLINE .)
    LLAVEDER        reduce using rule 87 (dec_slice -> LET MUT VARIABLE ASIGNAR slice_exp ENDLINE .)


state 154

    (88) slice_exp -> AND empty VARIABLE . empty BRACKETL rango BRACKETR
    (93) empty -> .

    BRACKETL        reduce using rule 93 (empty -> .)

    empty                          shift and go to state 167

state 155

    (89) slice_get -> VARIABLE empty DOT empty GET_SLICE empty . LPAREN valor_get RPAREN

    LPAREN          shift and go to state 168


state 156

    (92) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty . LPAREN AND U8 RPAREN

    LPAREN          shift and go to state 169


state 157

    (40) hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN . ENDLINE

    ENDLINE         shift and go to state 170


state 158

    (41) hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND VARIABLE . RPAREN ENDLINE

    RPAREN          shift and go to state 171


state 159

    (60) for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust . LLAVEDER

    LLAVEDER        shift and go to state 172


state 160

    (85) rango -> U8 DOT DOT . U8

    U8              shift and go to state 173


state 161

    (68) sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN ENDLINE .

    $end            reduce using rule 68 (sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 68 (sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN ENDLINE .)


state 162

    (66) argumentos_tipo -> tipos COMMA argumentos_tipo .

    RPAREN          reduce using rule 66 (argumentos_tipo -> tipos COMMA argumentos_tipo .)


state 163

    (62) argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos .
    (63) argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos . COMMA argumentos_juntos

    LLAVEDER        reduce using rule 62 (argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos .)
    COMMA           shift and go to state 174


state 164

    (64) argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE . tipos COMMA argumentos_juntos
    (22) tipos -> . DATATYPES
    (23) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 92
    NUMDATATYPES    shift and go to state 93

    tipos                          shift and go to state 175

state 165

    (34) print_args -> print_datos COMMA print_args .

    RPAREN          reduce using rule 34 (print_args -> print_datos COMMA print_args .)


state 166

    (37) hashset -> LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC . ENDLINE

    ENDLINE         shift and go to state 176


state 167

    (88) slice_exp -> AND empty VARIABLE empty . BRACKETL rango BRACKETR

    BRACKETL        shift and go to state 177


state 168

    (89) slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN . valor_get RPAREN
    (90) valor_get -> . rango
    (91) valor_get -> . U8
    (85) rango -> . U8 DOT DOT U8

    U8              shift and go to state 180

    valor_get                      shift and go to state 178
    rango                          shift and go to state 179

state 169

    (92) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN . AND U8 RPAREN

    AND             shift and go to state 181


state 170

    (40) hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE .

    $end            reduce using rule 40 (hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 40 (hashset_insert -> VARIABLE DOT INSERT_HASH LPAREN expresion RPAREN ENDLINE .)


state 171

    (41) hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN . ENDLINE

    ENDLINE         shift and go to state 182


state 172

    (60) for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER .

    $end            reduce using rule 60 (for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER .)
    LLAVEDER        reduce using rule 60 (for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER .)


state 173

    (85) rango -> U8 DOT DOT U8 .

    LLAVEIZ         reduce using rule 85 (rango -> U8 DOT DOT U8 .)
    RPAREN          reduce using rule 85 (rango -> U8 DOT DOT U8 .)
    BRACKETR        reduce using rule 85 (rango -> U8 DOT DOT U8 .)


state 174

    (63) argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos COMMA . argumentos_juntos
    (62) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos
    (63) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
    (64) argumentos_juntos -> . PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos

    VARIABLE        shift and go to state 121
    PUB             shift and go to state 123

    argumentos_juntos              shift and go to state 183

state 175

    (64) argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos . COMMA argumentos_juntos

    COMMA           shift and go to state 184


state 176

    (37) hashset -> LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE .

    $end            reduce using rule 37 (hashset -> LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE .)
    LLAVEDER        reduce using rule 37 (hashset -> LET MUT VARIABLE ASIGNAR HASHSET PATHSEP NEWFUNC ENDLINE .)


state 177

    (88) slice_exp -> AND empty VARIABLE empty BRACKETL . rango BRACKETR
    (85) rango -> . U8 DOT DOT U8

    U8              shift and go to state 118

    rango                          shift and go to state 185

state 178

    (89) slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get . RPAREN

    RPAREN          shift and go to state 186


state 179

    (90) valor_get -> rango .

    RPAREN          reduce using rule 90 (valor_get -> rango .)


state 180

    (91) valor_get -> U8 .
    (85) rango -> U8 . DOT DOT U8

    RPAREN          reduce using rule 91 (valor_get -> U8 .)
    DOT             shift and go to state 144


state 181

    (92) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND . U8 RPAREN

    U8              shift and go to state 187


state 182

    (41) hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE .

    $end            reduce using rule 41 (hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 41 (hashset_union -> VARIABLE DOT UNION_HASH LPAREN AND VARIABLE RPAREN ENDLINE .)


state 183

    (63) argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos .

    LLAVEDER        reduce using rule 63 (argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos .)


state 184

    (64) argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos COMMA . argumentos_juntos
    (62) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos
    (63) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
    (64) argumentos_juntos -> . PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos

    VARIABLE        shift and go to state 121
    PUB             shift and go to state 123

    argumentos_juntos              shift and go to state 188

state 185

    (88) slice_exp -> AND empty VARIABLE empty BRACKETL rango . BRACKETR

    BRACKETR        shift and go to state 189


state 186

    (89) slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN .

    $end            reduce using rule 89 (slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN .)
    LLAVEDER        reduce using rule 89 (slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN .)


state 187

    (92) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 . RPAREN

    RPAREN          shift and go to state 190


state 188

    (64) argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos .

    LLAVEDER        reduce using rule 64 (argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos .)


state 189

    (88) slice_exp -> AND empty VARIABLE empty BRACKETL rango BRACKETR .

    ENDLINE         reduce using rule 88 (slice_exp -> AND empty VARIABLE empty BRACKETL rango BRACKETR .)


state 190

    (92) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN .

    $end            reduce using rule 92 (slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN .)
    LLAVEDER        reduce using rule 92 (slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ASIGNAR in state 18 resolved as shift
WARNING: shift/reduce conflict for DOT in state 18 resolved as shift
WARNING: shift/reduce conflict for ASIGNAR in state 31 resolved as shift
WARNING: shift/reduce conflict for U8 in state 33 resolved as shift
WARNING: shift/reduce conflict for ASIGNAR in state 57 resolved as shift
