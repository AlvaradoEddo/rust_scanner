Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    ARROW
    AS
    ASYNC
    AWAIT
    BREAK
    B_FALSE
    B_TRUE
    CONST
    CONTIN
    CRATE
    DOLLAR
    DOTDOTDOT
    DYN
    ENUM
    ERRORPROP
    EXTERN
    IMPL
    LESSEQ
    LOOP
    MATCH
    MAYOR
    MAYORIGUAL
    MOD
    MOVE
    NOT
    NUMBER
    OR
    PRINT
    REF
    RETURN
    SELF
    SELFLOWERCASE
    STATIC
    SUPER
    TRAIT
    TYPE
    UNSAFE
    USE
    WHERE

Grammar

Rule 0     S' -> rust
Rule 1     rust -> asignacion
Rule 2     rust -> asignacion_sintipo
Rule 3     rust -> prints
Rule 4     rust -> hashfunc
Rule 5     rust -> conditional
Rule 6     rust -> conditional_asigned
Rule 7     rust -> for_loop
Rule 8     rust -> struct_s
Rule 9     rust -> while_loop
Rule 10    rust -> empty_vector
Rule 11    rust -> vector_methods
Rule 12    rust -> data_vector
Rule 13    rust -> slice_get
Rule 14    rust -> slice_contains
Rule 15    rust -> read_data
Rule 16    rust -> function
Rule 17    rust -> empty_function
Rule 18    asignacion -> declarador ASIGNAR expresion ENDLINE
Rule 19    asignacion -> other_operators ENDLINE
Rule 20    asignacion_sintipo -> declarador_sintipo ASIGNAR expresion_sintipo ENDLINE
Rule 21    other_operators -> VARIABLE oper_asig expresion
Rule 22    declarador -> VARIABLE
Rule 23    declarador -> let_asig
Rule 24    declarador_sintipo -> VARIABLE
Rule 25    declarador_sintipo -> let_asig_sintipo
Rule 26    let_asig -> LET var_tipo
Rule 27    let_asig -> LET MUT var_tipo
Rule 28    let_asig_sintipo -> LET MUT VARIABLE
Rule 29    let_asig_sintipo -> LET VARIABLE
Rule 30    var_tipo -> VARIABLE
Rule 31    var_tipo -> VARIABLE ASIGNATION_TYPE tipos
Rule 32    oper_asig -> ASIGNAR
Rule 33    oper_asig -> PLUSEQ
Rule 34    oper_asig -> MINUSEQ
Rule 35    oper_asig -> STAREQ
Rule 36    oper_asig -> SLASHEQ
Rule 37    prints -> PRINTS empty LPAREN print_expresion RPAREN empty ENDLINE
Rule 38    print_expresion -> STRING
Rule 39    print_expresion -> STRING COMMA print_args
Rule 40    print_args -> print_datos COMMA print_args
Rule 41    print_args -> print_datos
Rule 42    print_datos -> expresion
Rule 43    hashset -> HASHSET empty PATHSEP empty NEWFUNC
Rule 44    hashfunc -> hashset_insert
Rule 45    hashfunc -> hashset_union
Rule 46    hashset_insert -> VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE
Rule 47    hashset_union -> VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE
Rule 48    conditional_asigned -> declarador ASIGNAR conditional ENDLINE
Rule 49    conditional -> if_type validations LLAVEIZ rust LLAVEDER
Rule 50    if_type -> IF
Rule 51    if_type -> ELSE IF
Rule 52    if_type -> ELSE
Rule 53    validations -> comparison
Rule 54    validations -> comparison ANDAND validations
Rule 55    validations -> comparison OROR validations
Rule 56    comparison -> VARIABLE signo_comp VARIABLE
Rule 57    comparison -> VARIABLE signo_comp U8
Rule 58    comparison -> U8 signo_comp VARIABLE
Rule 59    signo_comp -> GREATER
Rule 60    signo_comp -> LESST
Rule 61    signo_comp -> GREATEQ
Rule 62    signo_comp -> EQUAL
Rule 63    signo_comp -> DIFFERENT
Rule 64    f_comparacion -> rango
Rule 65    f_comparacion -> VARIABLE
Rule 66    for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
Rule 67    struct_s -> STRUCT sent_stru
Rule 68    argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos
Rule 69    argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
Rule 70    argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
Rule 71    argumentos_tipo -> tipos
Rule 72    argumentos_tipo -> tipos COMMA argumentos_tipo
Rule 73    sent_stru -> UNIT ENDLINE
Rule 74    sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN ENDLINE
Rule 75    sent_stru -> VARIABLE LLAVEIZ argumentos_juntos LLAVEDER
Rule 76    op_mat -> art_exp
Rule 77    op_mat -> VARIABLE signo_arit art_exp
Rule 78    op_mat -> U8 signo_arit art_exp
Rule 79    art_exp -> VARIABLE signo_arit VARIABLE
Rule 80    art_exp -> U8 signo_arit VARIABLE
Rule 81    art_exp -> VARIABLE signo_arit U8
Rule 82    art_exp -> U8 signo_arit U8
Rule 83    signo_arit -> MAS
Rule 84    signo_arit -> MENOS
Rule 85    signo_arit -> MULT
Rule 86    signo_arit -> DIVISION
Rule 87    signo_arit -> MODULO
Rule 88    rango -> U8 DOT DOT U8
Rule 89    slice_exp -> AND empty VARIABLE empty BRACKETL rango BRACKETR
Rule 90    slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
Rule 91    valor_get -> rango
Rule 92    valor_get -> U8
Rule 93    slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
Rule 94    empty -> <empty>
Rule 95    while_loop -> WHILE validations LLAVEIZ rust LLAVEDER
Rule 96    read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
Rule 97    reference -> AND empty MUT VARIABLE
Rule 98    function -> FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
Rule 99    empty_function -> FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
Rule 100   arguments -> VARIABLE ASIGNATION_TYPE tipos
Rule 101   arguments -> VARIABLE ASIGNATION_TYPE tipos COMMA arguments
Rule 102   empty_vector -> declare_vector types_vector empty_vec
Rule 103   data_vector -> declare_vector types_vector vector_content
Rule 104   data_vector -> declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE
Rule 105   vector_content -> ASIGNAR VECTMACRO vect_list ENDLINE
Rule 106   vector_content -> ASIGNAR VECT PATHSEP FROM LPAREN vect_list RPAREN ENDLINE
Rule 107   vect_list -> BRACKETL vector_elements BRACKETR
Rule 108   vector_elements -> expresion
Rule 109   vector_elements -> expresion COMMA vector_elements
Rule 110   element_type -> U8 empty NUMDATATYPES
Rule 111   types_vector -> VECT empty LESST DATATYPES GREATER
Rule 112   types_vector -> VECT empty LESST NUMDATATYPES GREATER
Rule 113   declare_vector -> LET MUT VARIABLE ASIGNATION_TYPE
Rule 114   declare_vector -> LET VARIABLE ASIGNATION_TYPE
Rule 115   empty_vec -> ASIGNAR VECT PATHSEP NEWFUNC ENDLINE
Rule 116   empty_vec -> ASIGNAR VECTMACRO BRACKETL BRACKETR ENDLINE
Rule 117   empty_vec -> ASIGNAR VECT PATHSEP FROM LPAREN RPAREN ENDLINE
Rule 118   vector_methods -> VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
Rule 119   vector_methods -> VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
Rule 120   tipos -> DATATYPES
Rule 121   tipos -> NUMDATATYPES
Rule 122   expresion -> STRING
Rule 123   expresion -> U8
Rule 124   expresion -> F32
Rule 125   expresion -> VARIABLE
Rule 126   expresion_sintipo -> hashset
Rule 127   expresion_sintipo -> op_mat
Rule 128   expresion_sintipo -> slice_exp
Rule 129   expresion_sintipo -> expresion

Terminals, with rules where they appear

AND                  : 47 89 93 97
ANDAND               : 54
ARROW                : 
AS                   : 
ASIGNAR              : 18 20 32 48 104 105 106 115 116 117
ASIGNATION_TYPE      : 31 68 69 70 100 101 113 114
ASYNC                : 
AWAIT                : 
BRACKETL             : 89 104 107 116
BRACKETR             : 89 104 107 116
BREAK                : 
B_FALSE              : 
B_TRUE               : 
COMMA                : 39 40 69 70 72 101 104 109
CONST                : 
CONTAINS_SLICE       : 93
CONTIN               : 
CRATE                : 
DATATYPES            : 111 120
DIFFERENT            : 63
DIVISION             : 86
DOLLAR               : 
DOT                  : 46 47 88 88 90 93 96 118 119
DOTDOTDOT            : 
DYN                  : 
ELSE                 : 51 52
ENDLINE              : 18 19 20 37 46 47 48 73 74 96 104 105 106 115 116 117
ENUM                 : 
EQUAL                : 62
ERRORPROP            : 
EXTERN               : 
F32                  : 124
FOR                  : 66
FROM                 : 106 117
FUNCTION             : 98 99
GET_SLICE            : 90
GREATEQ              : 61
GREATER              : 59 111 112
HASHSET              : 43
IF                   : 50 51
IMPL                 : 
IN                   : 66
INSERT_HASH          : 46
IO                   : 96
LESSEQ               : 
LESST                : 60 111 112
LET                  : 26 27 28 29 113 114
LLAVEDER             : 49 66 75 95 98 99
LLAVEIZ              : 49 66 75 95 98 99
LOOP                 : 
LPAREN               : 37 46 47 74 90 93 96 96 98 99 106 117 118 119
MAS                  : 83
MATCH                : 
MAYOR                : 
MAYORIGUAL           : 
MENOS                : 84
MINUSEQ              : 34
MOD                  : 
MODULO               : 87
MOVE                 : 
MULT                 : 85
MUT                  : 27 28 97 113
NEWFUNC              : 43 115
NOT                  : 
NUMBER               : 
NUMDATATYPES         : 110 112 121
OR                   : 
OROR                 : 55
PATHSEP              : 43 96 106 115 117
PLUSEQ               : 33
POP_VEC              : 119
PRINT                : 
PRINTS               : 37
PUB                  : 70
PUSH_VEC             : 118
READ                 : 96
REF                  : 
RETURN               : 
RPAREN               : 37 46 47 74 90 93 96 96 98 99 106 117 118 119
SELF                 : 
SELFLOWERCASE        : 
SLASHEQ              : 36
STAREQ               : 35
STATIC               : 
STDIN                : 96
STRING               : 38 39 122
STRUCT               : 67
SUPER                : 
TRAIT                : 
TUPLE                : 74
TYPE                 : 
U8                   : 57 58 78 80 81 82 82 88 88 92 93 110 123
UNION_HASH           : 47
UNIT                 : 73
UNSAFE               : 
USE                  : 
VARIABLE             : 21 22 24 28 29 30 31 46 47 47 56 56 57 58 65 66 68 69 70 75 77 79 79 80 81 89 90 93 97 98 99 100 101 113 114 118 119 125
VECT                 : 106 111 112 115 117
VECTMACRO            : 104 105 116
WHERE                : 
WHILE                : 95
error                : 

Nonterminals, with rules where they appear

argumentos_juntos    : 69 70 75
argumentos_tipo      : 72 74
arguments            : 98 101
art_exp              : 76 77 78
asignacion           : 1
asignacion_sintipo   : 2
comparison           : 53 54 55
conditional          : 5 48
conditional_asigned  : 6
data_vector          : 12
declarador           : 18 48
declarador_sintipo   : 20
declare_vector       : 102 103 104
element_type         : 104
empty                : 37 37 43 43 46 46 46 46 47 47 47 47 47 89 89 90 90 90 93 93 93 96 96 96 96 97 110 111 112 118 118 119 119
empty_function       : 17
empty_vec            : 102
empty_vector         : 10
expresion            : 18 21 42 46 108 109 118 129
expresion_sintipo    : 20
f_comparacion        : 66
for_loop             : 7
function             : 16
hashfunc             : 4
hashset              : 126
hashset_insert       : 44
hashset_union        : 45
if_type              : 49
let_asig             : 23
let_asig_sintipo     : 25
op_mat               : 127
oper_asig            : 21
other_operators      : 19
print_args           : 39 40
print_datos          : 40 41
print_expresion      : 37
prints               : 3
rango                : 64 89 91
read_data            : 15
reference            : 96
rust                 : 49 66 95 98 99 0
sent_stru            : 67
signo_arit           : 77 78 79 80 81 82
signo_comp           : 56 57 58
slice_contains       : 14
slice_exp            : 128
slice_get            : 13
struct_s             : 8
tipos                : 31 68 69 70 71 72 100 101
types_vector         : 102 103
validations          : 49 54 55 95
valor_get            : 90
var_tipo             : 26 27
vect_list            : 105 106
vector_content       : 103
vector_elements      : 104 107 109
vector_methods       : 11
while_loop           : 9

Parsing method: LALR

state 0

    (0) S' -> . rust
    (1) rust -> . asignacion
    (2) rust -> . asignacion_sintipo
    (3) rust -> . prints
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . while_loop
    (10) rust -> . empty_vector
    (11) rust -> . vector_methods
    (12) rust -> . data_vector
    (13) rust -> . slice_get
    (14) rust -> . slice_contains
    (15) rust -> . read_data
    (16) rust -> . function
    (17) rust -> . empty_function
    (18) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (19) asignacion -> . other_operators ENDLINE
    (20) asignacion_sintipo -> . declarador_sintipo ASIGNAR expresion_sintipo ENDLINE
    (37) prints -> . PRINTS empty LPAREN print_expresion RPAREN empty ENDLINE
    (44) hashfunc -> . hashset_insert
    (45) hashfunc -> . hashset_union
    (49) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (48) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (66) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (67) struct_s -> . STRUCT sent_stru
    (95) while_loop -> . WHILE validations LLAVEIZ rust LLAVEDER
    (102) empty_vector -> . declare_vector types_vector empty_vec
    (118) vector_methods -> . VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (119) vector_methods -> . VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
    (103) data_vector -> . declare_vector types_vector vector_content
    (104) data_vector -> . declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE
    (90) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (93) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (96) read_data -> . IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (98) function -> . FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (99) empty_function -> . FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
    (22) declarador -> . VARIABLE
    (23) declarador -> . let_asig
    (21) other_operators -> . VARIABLE oper_asig expresion
    (24) declarador_sintipo -> . VARIABLE
    (25) declarador_sintipo -> . let_asig_sintipo
    (46) hashset_insert -> . VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE
    (47) hashset_union -> . VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE
    (50) if_type -> . IF
    (51) if_type -> . ELSE IF
    (52) if_type -> . ELSE
    (113) declare_vector -> . LET MUT VARIABLE ASIGNATION_TYPE
    (114) declare_vector -> . LET VARIABLE ASIGNATION_TYPE
    (26) let_asig -> . LET var_tipo
    (27) let_asig -> . LET MUT var_tipo
    (28) let_asig_sintipo -> . LET MUT VARIABLE
    (29) let_asig_sintipo -> . LET VARIABLE

    PRINTS          shift and go to state 22
    FOR             shift and go to state 26
    STRUCT          shift and go to state 28
    WHILE           shift and go to state 29
    VARIABLE        shift and go to state 27
    IO              shift and go to state 31
    FUNCTION        shift and go to state 32
    IF              shift and go to state 35
    ELSE            shift and go to state 36
    LET             shift and go to state 37

    rust                           shift and go to state 1
    asignacion                     shift and go to state 2
    asignacion_sintipo             shift and go to state 3
    prints                         shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    while_loop                     shift and go to state 10
    empty_vector                   shift and go to state 11
    vector_methods                 shift and go to state 12
    data_vector                    shift and go to state 13
    slice_get                      shift and go to state 14
    slice_contains                 shift and go to state 15
    read_data                      shift and go to state 16
    function                       shift and go to state 17
    empty_function                 shift and go to state 18
    declarador                     shift and go to state 19
    other_operators                shift and go to state 20
    declarador_sintipo             shift and go to state 21
    hashset_insert                 shift and go to state 23
    hashset_union                  shift and go to state 24
    if_type                        shift and go to state 25
    declare_vector                 shift and go to state 30
    let_asig                       shift and go to state 33
    let_asig_sintipo               shift and go to state 34

state 1

    (0) S' -> rust .



state 2

    (1) rust -> asignacion .

    $end            reduce using rule 1 (rust -> asignacion .)
    LLAVEDER        reduce using rule 1 (rust -> asignacion .)


state 3

    (2) rust -> asignacion_sintipo .

    $end            reduce using rule 2 (rust -> asignacion_sintipo .)
    LLAVEDER        reduce using rule 2 (rust -> asignacion_sintipo .)


state 4

    (3) rust -> prints .

    $end            reduce using rule 3 (rust -> prints .)
    LLAVEDER        reduce using rule 3 (rust -> prints .)


state 5

    (4) rust -> hashfunc .

    $end            reduce using rule 4 (rust -> hashfunc .)
    LLAVEDER        reduce using rule 4 (rust -> hashfunc .)


state 6

    (5) rust -> conditional .

    $end            reduce using rule 5 (rust -> conditional .)
    LLAVEDER        reduce using rule 5 (rust -> conditional .)


state 7

    (6) rust -> conditional_asigned .

    $end            reduce using rule 6 (rust -> conditional_asigned .)
    LLAVEDER        reduce using rule 6 (rust -> conditional_asigned .)


state 8

    (7) rust -> for_loop .

    $end            reduce using rule 7 (rust -> for_loop .)
    LLAVEDER        reduce using rule 7 (rust -> for_loop .)


state 9

    (8) rust -> struct_s .

    $end            reduce using rule 8 (rust -> struct_s .)
    LLAVEDER        reduce using rule 8 (rust -> struct_s .)


state 10

    (9) rust -> while_loop .

    $end            reduce using rule 9 (rust -> while_loop .)
    LLAVEDER        reduce using rule 9 (rust -> while_loop .)


state 11

    (10) rust -> empty_vector .

    $end            reduce using rule 10 (rust -> empty_vector .)
    LLAVEDER        reduce using rule 10 (rust -> empty_vector .)


state 12

    (11) rust -> vector_methods .

    $end            reduce using rule 11 (rust -> vector_methods .)
    LLAVEDER        reduce using rule 11 (rust -> vector_methods .)


state 13

    (12) rust -> data_vector .

    $end            reduce using rule 12 (rust -> data_vector .)
    LLAVEDER        reduce using rule 12 (rust -> data_vector .)


state 14

    (13) rust -> slice_get .

    $end            reduce using rule 13 (rust -> slice_get .)
    LLAVEDER        reduce using rule 13 (rust -> slice_get .)


state 15

    (14) rust -> slice_contains .

    $end            reduce using rule 14 (rust -> slice_contains .)
    LLAVEDER        reduce using rule 14 (rust -> slice_contains .)


state 16

    (15) rust -> read_data .

    $end            reduce using rule 15 (rust -> read_data .)
    LLAVEDER        reduce using rule 15 (rust -> read_data .)


state 17

    (16) rust -> function .

    $end            reduce using rule 16 (rust -> function .)
    LLAVEDER        reduce using rule 16 (rust -> function .)


state 18

    (17) rust -> empty_function .

    $end            reduce using rule 17 (rust -> empty_function .)
    LLAVEDER        reduce using rule 17 (rust -> empty_function .)


state 19

    (18) asignacion -> declarador . ASIGNAR expresion ENDLINE
    (48) conditional_asigned -> declarador . ASIGNAR conditional ENDLINE

    ASIGNAR         shift and go to state 38


state 20

    (19) asignacion -> other_operators . ENDLINE

    ENDLINE         shift and go to state 39


state 21

    (20) asignacion_sintipo -> declarador_sintipo . ASIGNAR expresion_sintipo ENDLINE

    ASIGNAR         shift and go to state 40


state 22

    (37) prints -> PRINTS . empty LPAREN print_expresion RPAREN empty ENDLINE
    (94) empty -> .

    LPAREN          reduce using rule 94 (empty -> .)

    empty                          shift and go to state 41

state 23

    (44) hashfunc -> hashset_insert .

    $end            reduce using rule 44 (hashfunc -> hashset_insert .)
    LLAVEDER        reduce using rule 44 (hashfunc -> hashset_insert .)


state 24

    (45) hashfunc -> hashset_union .

    $end            reduce using rule 45 (hashfunc -> hashset_union .)
    LLAVEDER        reduce using rule 45 (hashfunc -> hashset_union .)


state 25

    (49) conditional -> if_type . validations LLAVEIZ rust LLAVEDER
    (53) validations -> . comparison
    (54) validations -> . comparison ANDAND validations
    (55) validations -> . comparison OROR validations
    (56) comparison -> . VARIABLE signo_comp VARIABLE
    (57) comparison -> . VARIABLE signo_comp U8
    (58) comparison -> . U8 signo_comp VARIABLE

    VARIABLE        shift and go to state 44
    U8              shift and go to state 45

    validations                    shift and go to state 42
    comparison                     shift and go to state 43

state 26

    (66) for_loop -> FOR . VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER

    VARIABLE        shift and go to state 46


state 27

    (118) vector_methods -> VARIABLE . empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (119) vector_methods -> VARIABLE . empty DOT empty POP_VEC LPAREN RPAREN
    (90) slice_get -> VARIABLE . empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (93) slice_contains -> VARIABLE . empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (22) declarador -> VARIABLE .
    (21) other_operators -> VARIABLE . oper_asig expresion
    (24) declarador_sintipo -> VARIABLE .
    (46) hashset_insert -> VARIABLE . empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE
    (47) hashset_union -> VARIABLE . empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE
    (94) empty -> .
    (32) oper_asig -> . ASIGNAR
    (33) oper_asig -> . PLUSEQ
    (34) oper_asig -> . MINUSEQ
    (35) oper_asig -> . STAREQ
    (36) oper_asig -> . SLASHEQ

  ! reduce/reduce conflict for ASIGNAR resolved using rule 22 (declarador -> VARIABLE .)
  ! shift/reduce conflict for ASIGNAR resolved as shift
    DOT             reduce using rule 94 (empty -> .)
    ASIGNAR         shift and go to state 49
    PLUSEQ          shift and go to state 50
    MINUSEQ         shift and go to state 51
    STAREQ          shift and go to state 52
    SLASHEQ         shift and go to state 53

  ! ASIGNAR         [ reduce using rule 22 (declarador -> VARIABLE .) ]
  ! ASIGNAR         [ reduce using rule 24 (declarador_sintipo -> VARIABLE .) ]

    empty                          shift and go to state 47
    oper_asig                      shift and go to state 48

state 28

    (67) struct_s -> STRUCT . sent_stru
    (73) sent_stru -> . UNIT ENDLINE
    (74) sent_stru -> . TUPLE LPAREN argumentos_tipo RPAREN ENDLINE
    (75) sent_stru -> . VARIABLE LLAVEIZ argumentos_juntos LLAVEDER

    UNIT            shift and go to state 55
    TUPLE           shift and go to state 56
    VARIABLE        shift and go to state 57

    sent_stru                      shift and go to state 54

state 29

    (95) while_loop -> WHILE . validations LLAVEIZ rust LLAVEDER
    (53) validations -> . comparison
    (54) validations -> . comparison ANDAND validations
    (55) validations -> . comparison OROR validations
    (56) comparison -> . VARIABLE signo_comp VARIABLE
    (57) comparison -> . VARIABLE signo_comp U8
    (58) comparison -> . U8 signo_comp VARIABLE

    VARIABLE        shift and go to state 44
    U8              shift and go to state 45

    validations                    shift and go to state 58
    comparison                     shift and go to state 43

state 30

    (102) empty_vector -> declare_vector . types_vector empty_vec
    (103) data_vector -> declare_vector . types_vector vector_content
    (104) data_vector -> declare_vector . ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE
    (111) types_vector -> . VECT empty LESST DATATYPES GREATER
    (112) types_vector -> . VECT empty LESST NUMDATATYPES GREATER

    ASIGNAR         shift and go to state 60
    VECT            shift and go to state 61

    types_vector                   shift and go to state 59

state 31

    (96) read_data -> IO . empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (94) empty -> .

    PATHSEP         reduce using rule 94 (empty -> .)

    empty                          shift and go to state 62

state 32

    (98) function -> FUNCTION . VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (99) empty_function -> FUNCTION . VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER

    VARIABLE        shift and go to state 63


state 33

    (23) declarador -> let_asig .

    ASIGNAR         reduce using rule 23 (declarador -> let_asig .)


state 34

    (25) declarador_sintipo -> let_asig_sintipo .

    ASIGNAR         reduce using rule 25 (declarador_sintipo -> let_asig_sintipo .)


state 35

    (50) if_type -> IF .

    VARIABLE        reduce using rule 50 (if_type -> IF .)
    U8              reduce using rule 50 (if_type -> IF .)


state 36

    (51) if_type -> ELSE . IF
    (52) if_type -> ELSE .

    IF              shift and go to state 64
    VARIABLE        reduce using rule 52 (if_type -> ELSE .)
    U8              reduce using rule 52 (if_type -> ELSE .)


state 37

    (113) declare_vector -> LET . MUT VARIABLE ASIGNATION_TYPE
    (114) declare_vector -> LET . VARIABLE ASIGNATION_TYPE
    (26) let_asig -> LET . var_tipo
    (27) let_asig -> LET . MUT var_tipo
    (28) let_asig_sintipo -> LET . MUT VARIABLE
    (29) let_asig_sintipo -> LET . VARIABLE
    (30) var_tipo -> . VARIABLE
    (31) var_tipo -> . VARIABLE ASIGNATION_TYPE tipos

    MUT             shift and go to state 65
    VARIABLE        shift and go to state 66

    var_tipo                       shift and go to state 67

state 38

    (18) asignacion -> declarador ASIGNAR . expresion ENDLINE
    (48) conditional_asigned -> declarador ASIGNAR . conditional ENDLINE
    (122) expresion -> . STRING
    (123) expresion -> . U8
    (124) expresion -> . F32
    (125) expresion -> . VARIABLE
    (49) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (50) if_type -> . IF
    (51) if_type -> . ELSE IF
    (52) if_type -> . ELSE

    STRING          shift and go to state 70
    U8              shift and go to state 71
    F32             shift and go to state 72
    VARIABLE        shift and go to state 73
    IF              shift and go to state 35
    ELSE            shift and go to state 36

    expresion                      shift and go to state 68
    conditional                    shift and go to state 69
    if_type                        shift and go to state 25

state 39

    (19) asignacion -> other_operators ENDLINE .

    $end            reduce using rule 19 (asignacion -> other_operators ENDLINE .)
    LLAVEDER        reduce using rule 19 (asignacion -> other_operators ENDLINE .)


state 40

    (20) asignacion_sintipo -> declarador_sintipo ASIGNAR . expresion_sintipo ENDLINE
    (126) expresion_sintipo -> . hashset
    (127) expresion_sintipo -> . op_mat
    (128) expresion_sintipo -> . slice_exp
    (129) expresion_sintipo -> . expresion
    (43) hashset -> . HASHSET empty PATHSEP empty NEWFUNC
    (76) op_mat -> . art_exp
    (77) op_mat -> . VARIABLE signo_arit art_exp
    (78) op_mat -> . U8 signo_arit art_exp
    (89) slice_exp -> . AND empty VARIABLE empty BRACKETL rango BRACKETR
    (122) expresion -> . STRING
    (123) expresion -> . U8
    (124) expresion -> . F32
    (125) expresion -> . VARIABLE
    (79) art_exp -> . VARIABLE signo_arit VARIABLE
    (80) art_exp -> . U8 signo_arit VARIABLE
    (81) art_exp -> . VARIABLE signo_arit U8
    (82) art_exp -> . U8 signo_arit U8

    HASHSET         shift and go to state 79
    VARIABLE        shift and go to state 81
    U8              shift and go to state 82
    AND             shift and go to state 83
    STRING          shift and go to state 70
    F32             shift and go to state 72

    expresion_sintipo              shift and go to state 74
    hashset                        shift and go to state 75
    op_mat                         shift and go to state 76
    slice_exp                      shift and go to state 77
    expresion                      shift and go to state 78
    art_exp                        shift and go to state 80

state 41

    (37) prints -> PRINTS empty . LPAREN print_expresion RPAREN empty ENDLINE

    LPAREN          shift and go to state 84


state 42

    (49) conditional -> if_type validations . LLAVEIZ rust LLAVEDER

    LLAVEIZ         shift and go to state 85


state 43

    (53) validations -> comparison .
    (54) validations -> comparison . ANDAND validations
    (55) validations -> comparison . OROR validations

    LLAVEIZ         reduce using rule 53 (validations -> comparison .)
    ANDAND          shift and go to state 86
    OROR            shift and go to state 87


state 44

    (56) comparison -> VARIABLE . signo_comp VARIABLE
    (57) comparison -> VARIABLE . signo_comp U8
    (59) signo_comp -> . GREATER
    (60) signo_comp -> . LESST
    (61) signo_comp -> . GREATEQ
    (62) signo_comp -> . EQUAL
    (63) signo_comp -> . DIFFERENT

    GREATER         shift and go to state 89
    LESST           shift and go to state 90
    GREATEQ         shift and go to state 91
    EQUAL           shift and go to state 92
    DIFFERENT       shift and go to state 93

    signo_comp                     shift and go to state 88

state 45

    (58) comparison -> U8 . signo_comp VARIABLE
    (59) signo_comp -> . GREATER
    (60) signo_comp -> . LESST
    (61) signo_comp -> . GREATEQ
    (62) signo_comp -> . EQUAL
    (63) signo_comp -> . DIFFERENT

    GREATER         shift and go to state 89
    LESST           shift and go to state 90
    GREATEQ         shift and go to state 91
    EQUAL           shift and go to state 92
    DIFFERENT       shift and go to state 93

    signo_comp                     shift and go to state 94

state 46

    (66) for_loop -> FOR VARIABLE . IN f_comparacion LLAVEIZ rust LLAVEDER

    IN              shift and go to state 95


state 47

    (118) vector_methods -> VARIABLE empty . DOT empty PUSH_VEC LPAREN expresion RPAREN
    (119) vector_methods -> VARIABLE empty . DOT empty POP_VEC LPAREN RPAREN
    (90) slice_get -> VARIABLE empty . DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (93) slice_contains -> VARIABLE empty . DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (46) hashset_insert -> VARIABLE empty . DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE
    (47) hashset_union -> VARIABLE empty . DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE

    DOT             shift and go to state 96


state 48

    (21) other_operators -> VARIABLE oper_asig . expresion
    (122) expresion -> . STRING
    (123) expresion -> . U8
    (124) expresion -> . F32
    (125) expresion -> . VARIABLE

    STRING          shift and go to state 70
    U8              shift and go to state 71
    F32             shift and go to state 72
    VARIABLE        shift and go to state 73

    expresion                      shift and go to state 97

state 49

    (32) oper_asig -> ASIGNAR .

    STRING          reduce using rule 32 (oper_asig -> ASIGNAR .)
    U8              reduce using rule 32 (oper_asig -> ASIGNAR .)
    F32             reduce using rule 32 (oper_asig -> ASIGNAR .)
    VARIABLE        reduce using rule 32 (oper_asig -> ASIGNAR .)


state 50

    (33) oper_asig -> PLUSEQ .

    STRING          reduce using rule 33 (oper_asig -> PLUSEQ .)
    U8              reduce using rule 33 (oper_asig -> PLUSEQ .)
    F32             reduce using rule 33 (oper_asig -> PLUSEQ .)
    VARIABLE        reduce using rule 33 (oper_asig -> PLUSEQ .)


state 51

    (34) oper_asig -> MINUSEQ .

    STRING          reduce using rule 34 (oper_asig -> MINUSEQ .)
    U8              reduce using rule 34 (oper_asig -> MINUSEQ .)
    F32             reduce using rule 34 (oper_asig -> MINUSEQ .)
    VARIABLE        reduce using rule 34 (oper_asig -> MINUSEQ .)


state 52

    (35) oper_asig -> STAREQ .

    STRING          reduce using rule 35 (oper_asig -> STAREQ .)
    U8              reduce using rule 35 (oper_asig -> STAREQ .)
    F32             reduce using rule 35 (oper_asig -> STAREQ .)
    VARIABLE        reduce using rule 35 (oper_asig -> STAREQ .)


state 53

    (36) oper_asig -> SLASHEQ .

    STRING          reduce using rule 36 (oper_asig -> SLASHEQ .)
    U8              reduce using rule 36 (oper_asig -> SLASHEQ .)
    F32             reduce using rule 36 (oper_asig -> SLASHEQ .)
    VARIABLE        reduce using rule 36 (oper_asig -> SLASHEQ .)


state 54

    (67) struct_s -> STRUCT sent_stru .

    $end            reduce using rule 67 (struct_s -> STRUCT sent_stru .)
    LLAVEDER        reduce using rule 67 (struct_s -> STRUCT sent_stru .)


state 55

    (73) sent_stru -> UNIT . ENDLINE

    ENDLINE         shift and go to state 98


state 56

    (74) sent_stru -> TUPLE . LPAREN argumentos_tipo RPAREN ENDLINE

    LPAREN          shift and go to state 99


state 57

    (75) sent_stru -> VARIABLE . LLAVEIZ argumentos_juntos LLAVEDER

    LLAVEIZ         shift and go to state 100


state 58

    (95) while_loop -> WHILE validations . LLAVEIZ rust LLAVEDER

    LLAVEIZ         shift and go to state 101


state 59

    (102) empty_vector -> declare_vector types_vector . empty_vec
    (103) data_vector -> declare_vector types_vector . vector_content
    (115) empty_vec -> . ASIGNAR VECT PATHSEP NEWFUNC ENDLINE
    (116) empty_vec -> . ASIGNAR VECTMACRO BRACKETL BRACKETR ENDLINE
    (117) empty_vec -> . ASIGNAR VECT PATHSEP FROM LPAREN RPAREN ENDLINE
    (105) vector_content -> . ASIGNAR VECTMACRO vect_list ENDLINE
    (106) vector_content -> . ASIGNAR VECT PATHSEP FROM LPAREN vect_list RPAREN ENDLINE

    ASIGNAR         shift and go to state 104

    empty_vec                      shift and go to state 102
    vector_content                 shift and go to state 103

state 60

    (104) data_vector -> declare_vector ASIGNAR . VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE

    VECTMACRO       shift and go to state 105


state 61

    (111) types_vector -> VECT . empty LESST DATATYPES GREATER
    (112) types_vector -> VECT . empty LESST NUMDATATYPES GREATER
    (94) empty -> .

    LESST           reduce using rule 94 (empty -> .)

    empty                          shift and go to state 106

state 62

    (96) read_data -> IO empty . PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE

    PATHSEP         shift and go to state 107


state 63

    (98) function -> FUNCTION VARIABLE . LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (99) empty_function -> FUNCTION VARIABLE . LPAREN RPAREN LLAVEIZ rust LLAVEDER

    LPAREN          shift and go to state 108


state 64

    (51) if_type -> ELSE IF .

    VARIABLE        reduce using rule 51 (if_type -> ELSE IF .)
    U8              reduce using rule 51 (if_type -> ELSE IF .)


state 65

    (113) declare_vector -> LET MUT . VARIABLE ASIGNATION_TYPE
    (27) let_asig -> LET MUT . var_tipo
    (28) let_asig_sintipo -> LET MUT . VARIABLE
    (30) var_tipo -> . VARIABLE
    (31) var_tipo -> . VARIABLE ASIGNATION_TYPE tipos

    VARIABLE        shift and go to state 109

    var_tipo                       shift and go to state 110

state 66

    (114) declare_vector -> LET VARIABLE . ASIGNATION_TYPE
    (29) let_asig_sintipo -> LET VARIABLE .
    (30) var_tipo -> VARIABLE .
    (31) var_tipo -> VARIABLE . ASIGNATION_TYPE tipos

  ! reduce/reduce conflict for ASIGNAR resolved using rule 29 (let_asig_sintipo -> LET VARIABLE .)
    ASIGNATION_TYPE shift and go to state 111
    ASIGNAR         reduce using rule 29 (let_asig_sintipo -> LET VARIABLE .)

  ! ASIGNAR         [ reduce using rule 30 (var_tipo -> VARIABLE .) ]


state 67

    (26) let_asig -> LET var_tipo .

    ASIGNAR         reduce using rule 26 (let_asig -> LET var_tipo .)


state 68

    (18) asignacion -> declarador ASIGNAR expresion . ENDLINE

    ENDLINE         shift and go to state 112


state 69

    (48) conditional_asigned -> declarador ASIGNAR conditional . ENDLINE

    ENDLINE         shift and go to state 113


state 70

    (122) expresion -> STRING .

    ENDLINE         reduce using rule 122 (expresion -> STRING .)
    COMMA           reduce using rule 122 (expresion -> STRING .)
    RPAREN          reduce using rule 122 (expresion -> STRING .)
    BRACKETR        reduce using rule 122 (expresion -> STRING .)


state 71

    (123) expresion -> U8 .

    ENDLINE         reduce using rule 123 (expresion -> U8 .)
    COMMA           reduce using rule 123 (expresion -> U8 .)
    RPAREN          reduce using rule 123 (expresion -> U8 .)
    BRACKETR        reduce using rule 123 (expresion -> U8 .)


state 72

    (124) expresion -> F32 .

    ENDLINE         reduce using rule 124 (expresion -> F32 .)
    COMMA           reduce using rule 124 (expresion -> F32 .)
    RPAREN          reduce using rule 124 (expresion -> F32 .)
    BRACKETR        reduce using rule 124 (expresion -> F32 .)


state 73

    (125) expresion -> VARIABLE .

    ENDLINE         reduce using rule 125 (expresion -> VARIABLE .)
    COMMA           reduce using rule 125 (expresion -> VARIABLE .)
    RPAREN          reduce using rule 125 (expresion -> VARIABLE .)
    BRACKETR        reduce using rule 125 (expresion -> VARIABLE .)


state 74

    (20) asignacion_sintipo -> declarador_sintipo ASIGNAR expresion_sintipo . ENDLINE

    ENDLINE         shift and go to state 114


state 75

    (126) expresion_sintipo -> hashset .

    ENDLINE         reduce using rule 126 (expresion_sintipo -> hashset .)


state 76

    (127) expresion_sintipo -> op_mat .

    ENDLINE         reduce using rule 127 (expresion_sintipo -> op_mat .)


state 77

    (128) expresion_sintipo -> slice_exp .

    ENDLINE         reduce using rule 128 (expresion_sintipo -> slice_exp .)


state 78

    (129) expresion_sintipo -> expresion .

    ENDLINE         reduce using rule 129 (expresion_sintipo -> expresion .)


state 79

    (43) hashset -> HASHSET . empty PATHSEP empty NEWFUNC
    (94) empty -> .

    PATHSEP         reduce using rule 94 (empty -> .)

    empty                          shift and go to state 115

state 80

    (76) op_mat -> art_exp .

    ENDLINE         reduce using rule 76 (op_mat -> art_exp .)


state 81

    (77) op_mat -> VARIABLE . signo_arit art_exp
    (125) expresion -> VARIABLE .
    (79) art_exp -> VARIABLE . signo_arit VARIABLE
    (81) art_exp -> VARIABLE . signo_arit U8
    (83) signo_arit -> . MAS
    (84) signo_arit -> . MENOS
    (85) signo_arit -> . MULT
    (86) signo_arit -> . DIVISION
    (87) signo_arit -> . MODULO

    ENDLINE         reduce using rule 125 (expresion -> VARIABLE .)
    MAS             shift and go to state 117
    MENOS           shift and go to state 118
    MULT            shift and go to state 119
    DIVISION        shift and go to state 120
    MODULO          shift and go to state 121

    signo_arit                     shift and go to state 116

state 82

    (78) op_mat -> U8 . signo_arit art_exp
    (123) expresion -> U8 .
    (80) art_exp -> U8 . signo_arit VARIABLE
    (82) art_exp -> U8 . signo_arit U8
    (83) signo_arit -> . MAS
    (84) signo_arit -> . MENOS
    (85) signo_arit -> . MULT
    (86) signo_arit -> . DIVISION
    (87) signo_arit -> . MODULO

    ENDLINE         reduce using rule 123 (expresion -> U8 .)
    MAS             shift and go to state 117
    MENOS           shift and go to state 118
    MULT            shift and go to state 119
    DIVISION        shift and go to state 120
    MODULO          shift and go to state 121

    signo_arit                     shift and go to state 122

state 83

    (89) slice_exp -> AND . empty VARIABLE empty BRACKETL rango BRACKETR
    (94) empty -> .

    VARIABLE        reduce using rule 94 (empty -> .)

    empty                          shift and go to state 123

state 84

    (37) prints -> PRINTS empty LPAREN . print_expresion RPAREN empty ENDLINE
    (38) print_expresion -> . STRING
    (39) print_expresion -> . STRING COMMA print_args

    STRING          shift and go to state 125

    print_expresion                shift and go to state 124

state 85

    (49) conditional -> if_type validations LLAVEIZ . rust LLAVEDER
    (1) rust -> . asignacion
    (2) rust -> . asignacion_sintipo
    (3) rust -> . prints
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . while_loop
    (10) rust -> . empty_vector
    (11) rust -> . vector_methods
    (12) rust -> . data_vector
    (13) rust -> . slice_get
    (14) rust -> . slice_contains
    (15) rust -> . read_data
    (16) rust -> . function
    (17) rust -> . empty_function
    (18) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (19) asignacion -> . other_operators ENDLINE
    (20) asignacion_sintipo -> . declarador_sintipo ASIGNAR expresion_sintipo ENDLINE
    (37) prints -> . PRINTS empty LPAREN print_expresion RPAREN empty ENDLINE
    (44) hashfunc -> . hashset_insert
    (45) hashfunc -> . hashset_union
    (49) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (48) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (66) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (67) struct_s -> . STRUCT sent_stru
    (95) while_loop -> . WHILE validations LLAVEIZ rust LLAVEDER
    (102) empty_vector -> . declare_vector types_vector empty_vec
    (118) vector_methods -> . VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (119) vector_methods -> . VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
    (103) data_vector -> . declare_vector types_vector vector_content
    (104) data_vector -> . declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE
    (90) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (93) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (96) read_data -> . IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (98) function -> . FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (99) empty_function -> . FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
    (22) declarador -> . VARIABLE
    (23) declarador -> . let_asig
    (21) other_operators -> . VARIABLE oper_asig expresion
    (24) declarador_sintipo -> . VARIABLE
    (25) declarador_sintipo -> . let_asig_sintipo
    (46) hashset_insert -> . VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE
    (47) hashset_union -> . VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE
    (50) if_type -> . IF
    (51) if_type -> . ELSE IF
    (52) if_type -> . ELSE
    (113) declare_vector -> . LET MUT VARIABLE ASIGNATION_TYPE
    (114) declare_vector -> . LET VARIABLE ASIGNATION_TYPE
    (26) let_asig -> . LET var_tipo
    (27) let_asig -> . LET MUT var_tipo
    (28) let_asig_sintipo -> . LET MUT VARIABLE
    (29) let_asig_sintipo -> . LET VARIABLE

    PRINTS          shift and go to state 22
    FOR             shift and go to state 26
    STRUCT          shift and go to state 28
    WHILE           shift and go to state 29
    VARIABLE        shift and go to state 27
    IO              shift and go to state 31
    FUNCTION        shift and go to state 32
    IF              shift and go to state 35
    ELSE            shift and go to state 36
    LET             shift and go to state 37

    if_type                        shift and go to state 25
    rust                           shift and go to state 126
    asignacion                     shift and go to state 2
    asignacion_sintipo             shift and go to state 3
    prints                         shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    while_loop                     shift and go to state 10
    empty_vector                   shift and go to state 11
    vector_methods                 shift and go to state 12
    data_vector                    shift and go to state 13
    slice_get                      shift and go to state 14
    slice_contains                 shift and go to state 15
    read_data                      shift and go to state 16
    function                       shift and go to state 17
    empty_function                 shift and go to state 18
    declarador                     shift and go to state 19
    other_operators                shift and go to state 20
    declarador_sintipo             shift and go to state 21
    hashset_insert                 shift and go to state 23
    hashset_union                  shift and go to state 24
    declare_vector                 shift and go to state 30
    let_asig                       shift and go to state 33
    let_asig_sintipo               shift and go to state 34

state 86

    (54) validations -> comparison ANDAND . validations
    (53) validations -> . comparison
    (54) validations -> . comparison ANDAND validations
    (55) validations -> . comparison OROR validations
    (56) comparison -> . VARIABLE signo_comp VARIABLE
    (57) comparison -> . VARIABLE signo_comp U8
    (58) comparison -> . U8 signo_comp VARIABLE

    VARIABLE        shift and go to state 44
    U8              shift and go to state 45

    comparison                     shift and go to state 43
    validations                    shift and go to state 127

state 87

    (55) validations -> comparison OROR . validations
    (53) validations -> . comparison
    (54) validations -> . comparison ANDAND validations
    (55) validations -> . comparison OROR validations
    (56) comparison -> . VARIABLE signo_comp VARIABLE
    (57) comparison -> . VARIABLE signo_comp U8
    (58) comparison -> . U8 signo_comp VARIABLE

    VARIABLE        shift and go to state 44
    U8              shift and go to state 45

    comparison                     shift and go to state 43
    validations                    shift and go to state 128

state 88

    (56) comparison -> VARIABLE signo_comp . VARIABLE
    (57) comparison -> VARIABLE signo_comp . U8

    VARIABLE        shift and go to state 129
    U8              shift and go to state 130


state 89

    (59) signo_comp -> GREATER .

    VARIABLE        reduce using rule 59 (signo_comp -> GREATER .)
    U8              reduce using rule 59 (signo_comp -> GREATER .)


state 90

    (60) signo_comp -> LESST .

    VARIABLE        reduce using rule 60 (signo_comp -> LESST .)
    U8              reduce using rule 60 (signo_comp -> LESST .)


state 91

    (61) signo_comp -> GREATEQ .

    VARIABLE        reduce using rule 61 (signo_comp -> GREATEQ .)
    U8              reduce using rule 61 (signo_comp -> GREATEQ .)


state 92

    (62) signo_comp -> EQUAL .

    VARIABLE        reduce using rule 62 (signo_comp -> EQUAL .)
    U8              reduce using rule 62 (signo_comp -> EQUAL .)


state 93

    (63) signo_comp -> DIFFERENT .

    VARIABLE        reduce using rule 63 (signo_comp -> DIFFERENT .)
    U8              reduce using rule 63 (signo_comp -> DIFFERENT .)


state 94

    (58) comparison -> U8 signo_comp . VARIABLE

    VARIABLE        shift and go to state 131


state 95

    (66) for_loop -> FOR VARIABLE IN . f_comparacion LLAVEIZ rust LLAVEDER
    (64) f_comparacion -> . rango
    (65) f_comparacion -> . VARIABLE
    (88) rango -> . U8 DOT DOT U8

    VARIABLE        shift and go to state 132
    U8              shift and go to state 135

    f_comparacion                  shift and go to state 133
    rango                          shift and go to state 134

state 96

    (118) vector_methods -> VARIABLE empty DOT . empty PUSH_VEC LPAREN expresion RPAREN
    (119) vector_methods -> VARIABLE empty DOT . empty POP_VEC LPAREN RPAREN
    (90) slice_get -> VARIABLE empty DOT . empty GET_SLICE empty LPAREN valor_get RPAREN
    (93) slice_contains -> VARIABLE empty DOT . empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (46) hashset_insert -> VARIABLE empty DOT . empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE
    (47) hashset_union -> VARIABLE empty DOT . empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE
    (94) empty -> .

    PUSH_VEC        reduce using rule 94 (empty -> .)
    POP_VEC         reduce using rule 94 (empty -> .)
    GET_SLICE       reduce using rule 94 (empty -> .)
    CONTAINS_SLICE  reduce using rule 94 (empty -> .)
    INSERT_HASH     reduce using rule 94 (empty -> .)
    UNION_HASH      reduce using rule 94 (empty -> .)

    empty                          shift and go to state 136

state 97

    (21) other_operators -> VARIABLE oper_asig expresion .

    ENDLINE         reduce using rule 21 (other_operators -> VARIABLE oper_asig expresion .)


state 98

    (73) sent_stru -> UNIT ENDLINE .

    $end            reduce using rule 73 (sent_stru -> UNIT ENDLINE .)
    LLAVEDER        reduce using rule 73 (sent_stru -> UNIT ENDLINE .)


state 99

    (74) sent_stru -> TUPLE LPAREN . argumentos_tipo RPAREN ENDLINE
    (71) argumentos_tipo -> . tipos
    (72) argumentos_tipo -> . tipos COMMA argumentos_tipo
    (120) tipos -> . DATATYPES
    (121) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 139
    NUMDATATYPES    shift and go to state 140

    argumentos_tipo                shift and go to state 137
    tipos                          shift and go to state 138

state 100

    (75) sent_stru -> VARIABLE LLAVEIZ . argumentos_juntos LLAVEDER
    (68) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos
    (69) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
    (70) argumentos_juntos -> . PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos

    VARIABLE        shift and go to state 141
    PUB             shift and go to state 143

    argumentos_juntos              shift and go to state 142

state 101

    (95) while_loop -> WHILE validations LLAVEIZ . rust LLAVEDER
    (1) rust -> . asignacion
    (2) rust -> . asignacion_sintipo
    (3) rust -> . prints
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . while_loop
    (10) rust -> . empty_vector
    (11) rust -> . vector_methods
    (12) rust -> . data_vector
    (13) rust -> . slice_get
    (14) rust -> . slice_contains
    (15) rust -> . read_data
    (16) rust -> . function
    (17) rust -> . empty_function
    (18) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (19) asignacion -> . other_operators ENDLINE
    (20) asignacion_sintipo -> . declarador_sintipo ASIGNAR expresion_sintipo ENDLINE
    (37) prints -> . PRINTS empty LPAREN print_expresion RPAREN empty ENDLINE
    (44) hashfunc -> . hashset_insert
    (45) hashfunc -> . hashset_union
    (49) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (48) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (66) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (67) struct_s -> . STRUCT sent_stru
    (95) while_loop -> . WHILE validations LLAVEIZ rust LLAVEDER
    (102) empty_vector -> . declare_vector types_vector empty_vec
    (118) vector_methods -> . VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (119) vector_methods -> . VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
    (103) data_vector -> . declare_vector types_vector vector_content
    (104) data_vector -> . declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE
    (90) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (93) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (96) read_data -> . IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (98) function -> . FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (99) empty_function -> . FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
    (22) declarador -> . VARIABLE
    (23) declarador -> . let_asig
    (21) other_operators -> . VARIABLE oper_asig expresion
    (24) declarador_sintipo -> . VARIABLE
    (25) declarador_sintipo -> . let_asig_sintipo
    (46) hashset_insert -> . VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE
    (47) hashset_union -> . VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE
    (50) if_type -> . IF
    (51) if_type -> . ELSE IF
    (52) if_type -> . ELSE
    (113) declare_vector -> . LET MUT VARIABLE ASIGNATION_TYPE
    (114) declare_vector -> . LET VARIABLE ASIGNATION_TYPE
    (26) let_asig -> . LET var_tipo
    (27) let_asig -> . LET MUT var_tipo
    (28) let_asig_sintipo -> . LET MUT VARIABLE
    (29) let_asig_sintipo -> . LET VARIABLE

    PRINTS          shift and go to state 22
    FOR             shift and go to state 26
    STRUCT          shift and go to state 28
    WHILE           shift and go to state 29
    VARIABLE        shift and go to state 27
    IO              shift and go to state 31
    FUNCTION        shift and go to state 32
    IF              shift and go to state 35
    ELSE            shift and go to state 36
    LET             shift and go to state 37

    rust                           shift and go to state 144
    asignacion                     shift and go to state 2
    asignacion_sintipo             shift and go to state 3
    prints                         shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    while_loop                     shift and go to state 10
    empty_vector                   shift and go to state 11
    vector_methods                 shift and go to state 12
    data_vector                    shift and go to state 13
    slice_get                      shift and go to state 14
    slice_contains                 shift and go to state 15
    read_data                      shift and go to state 16
    function                       shift and go to state 17
    empty_function                 shift and go to state 18
    declarador                     shift and go to state 19
    other_operators                shift and go to state 20
    declarador_sintipo             shift and go to state 21
    hashset_insert                 shift and go to state 23
    hashset_union                  shift and go to state 24
    if_type                        shift and go to state 25
    declare_vector                 shift and go to state 30
    let_asig                       shift and go to state 33
    let_asig_sintipo               shift and go to state 34

state 102

    (102) empty_vector -> declare_vector types_vector empty_vec .

    $end            reduce using rule 102 (empty_vector -> declare_vector types_vector empty_vec .)
    LLAVEDER        reduce using rule 102 (empty_vector -> declare_vector types_vector empty_vec .)


state 103

    (103) data_vector -> declare_vector types_vector vector_content .

    $end            reduce using rule 103 (data_vector -> declare_vector types_vector vector_content .)
    LLAVEDER        reduce using rule 103 (data_vector -> declare_vector types_vector vector_content .)


state 104

    (115) empty_vec -> ASIGNAR . VECT PATHSEP NEWFUNC ENDLINE
    (116) empty_vec -> ASIGNAR . VECTMACRO BRACKETL BRACKETR ENDLINE
    (117) empty_vec -> ASIGNAR . VECT PATHSEP FROM LPAREN RPAREN ENDLINE
    (105) vector_content -> ASIGNAR . VECTMACRO vect_list ENDLINE
    (106) vector_content -> ASIGNAR . VECT PATHSEP FROM LPAREN vect_list RPAREN ENDLINE

    VECT            shift and go to state 145
    VECTMACRO       shift and go to state 146


state 105

    (104) data_vector -> declare_vector ASIGNAR VECTMACRO . BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE

    BRACKETL        shift and go to state 147


state 106

    (111) types_vector -> VECT empty . LESST DATATYPES GREATER
    (112) types_vector -> VECT empty . LESST NUMDATATYPES GREATER

    LESST           shift and go to state 148


state 107

    (96) read_data -> IO empty PATHSEP . empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (94) empty -> .

    STDIN           reduce using rule 94 (empty -> .)

    empty                          shift and go to state 149

state 108

    (98) function -> FUNCTION VARIABLE LPAREN . arguments RPAREN LLAVEIZ rust LLAVEDER
    (99) empty_function -> FUNCTION VARIABLE LPAREN . RPAREN LLAVEIZ rust LLAVEDER
    (100) arguments -> . VARIABLE ASIGNATION_TYPE tipos
    (101) arguments -> . VARIABLE ASIGNATION_TYPE tipos COMMA arguments

    RPAREN          shift and go to state 152
    VARIABLE        shift and go to state 150

    arguments                      shift and go to state 151

state 109

    (113) declare_vector -> LET MUT VARIABLE . ASIGNATION_TYPE
    (28) let_asig_sintipo -> LET MUT VARIABLE .
    (30) var_tipo -> VARIABLE .
    (31) var_tipo -> VARIABLE . ASIGNATION_TYPE tipos

  ! reduce/reduce conflict for ASIGNAR resolved using rule 28 (let_asig_sintipo -> LET MUT VARIABLE .)
    ASIGNATION_TYPE shift and go to state 153
    ASIGNAR         reduce using rule 28 (let_asig_sintipo -> LET MUT VARIABLE .)

  ! ASIGNAR         [ reduce using rule 30 (var_tipo -> VARIABLE .) ]


state 110

    (27) let_asig -> LET MUT var_tipo .

    ASIGNAR         reduce using rule 27 (let_asig -> LET MUT var_tipo .)


state 111

    (114) declare_vector -> LET VARIABLE ASIGNATION_TYPE .
    (31) var_tipo -> VARIABLE ASIGNATION_TYPE . tipos
    (120) tipos -> . DATATYPES
    (121) tipos -> . NUMDATATYPES

    ASIGNAR         reduce using rule 114 (declare_vector -> LET VARIABLE ASIGNATION_TYPE .)
    VECT            reduce using rule 114 (declare_vector -> LET VARIABLE ASIGNATION_TYPE .)
    DATATYPES       shift and go to state 139
    NUMDATATYPES    shift and go to state 140

    tipos                          shift and go to state 154

state 112

    (18) asignacion -> declarador ASIGNAR expresion ENDLINE .

    $end            reduce using rule 18 (asignacion -> declarador ASIGNAR expresion ENDLINE .)
    LLAVEDER        reduce using rule 18 (asignacion -> declarador ASIGNAR expresion ENDLINE .)


state 113

    (48) conditional_asigned -> declarador ASIGNAR conditional ENDLINE .

    $end            reduce using rule 48 (conditional_asigned -> declarador ASIGNAR conditional ENDLINE .)
    LLAVEDER        reduce using rule 48 (conditional_asigned -> declarador ASIGNAR conditional ENDLINE .)


state 114

    (20) asignacion_sintipo -> declarador_sintipo ASIGNAR expresion_sintipo ENDLINE .

    $end            reduce using rule 20 (asignacion_sintipo -> declarador_sintipo ASIGNAR expresion_sintipo ENDLINE .)
    LLAVEDER        reduce using rule 20 (asignacion_sintipo -> declarador_sintipo ASIGNAR expresion_sintipo ENDLINE .)


state 115

    (43) hashset -> HASHSET empty . PATHSEP empty NEWFUNC

    PATHSEP         shift and go to state 155


state 116

    (77) op_mat -> VARIABLE signo_arit . art_exp
    (79) art_exp -> VARIABLE signo_arit . VARIABLE
    (81) art_exp -> VARIABLE signo_arit . U8
    (79) art_exp -> . VARIABLE signo_arit VARIABLE
    (80) art_exp -> . U8 signo_arit VARIABLE
    (81) art_exp -> . VARIABLE signo_arit U8
    (82) art_exp -> . U8 signo_arit U8

    VARIABLE        shift and go to state 156
    U8              shift and go to state 158

    art_exp                        shift and go to state 157

state 117

    (83) signo_arit -> MAS .

    VARIABLE        reduce using rule 83 (signo_arit -> MAS .)
    U8              reduce using rule 83 (signo_arit -> MAS .)


state 118

    (84) signo_arit -> MENOS .

    VARIABLE        reduce using rule 84 (signo_arit -> MENOS .)
    U8              reduce using rule 84 (signo_arit -> MENOS .)


state 119

    (85) signo_arit -> MULT .

    VARIABLE        reduce using rule 85 (signo_arit -> MULT .)
    U8              reduce using rule 85 (signo_arit -> MULT .)


state 120

    (86) signo_arit -> DIVISION .

    VARIABLE        reduce using rule 86 (signo_arit -> DIVISION .)
    U8              reduce using rule 86 (signo_arit -> DIVISION .)


state 121

    (87) signo_arit -> MODULO .

    VARIABLE        reduce using rule 87 (signo_arit -> MODULO .)
    U8              reduce using rule 87 (signo_arit -> MODULO .)


state 122

    (78) op_mat -> U8 signo_arit . art_exp
    (80) art_exp -> U8 signo_arit . VARIABLE
    (82) art_exp -> U8 signo_arit . U8
    (79) art_exp -> . VARIABLE signo_arit VARIABLE
    (80) art_exp -> . U8 signo_arit VARIABLE
    (81) art_exp -> . VARIABLE signo_arit U8
    (82) art_exp -> . U8 signo_arit U8

    VARIABLE        shift and go to state 161
    U8              shift and go to state 159

    art_exp                        shift and go to state 160

state 123

    (89) slice_exp -> AND empty . VARIABLE empty BRACKETL rango BRACKETR

    VARIABLE        shift and go to state 162


state 124

    (37) prints -> PRINTS empty LPAREN print_expresion . RPAREN empty ENDLINE

    RPAREN          shift and go to state 163


state 125

    (38) print_expresion -> STRING .
    (39) print_expresion -> STRING . COMMA print_args

    RPAREN          reduce using rule 38 (print_expresion -> STRING .)
    COMMA           shift and go to state 164


state 126

    (49) conditional -> if_type validations LLAVEIZ rust . LLAVEDER

    LLAVEDER        shift and go to state 165


state 127

    (54) validations -> comparison ANDAND validations .

    LLAVEIZ         reduce using rule 54 (validations -> comparison ANDAND validations .)


state 128

    (55) validations -> comparison OROR validations .

    LLAVEIZ         reduce using rule 55 (validations -> comparison OROR validations .)


state 129

    (56) comparison -> VARIABLE signo_comp VARIABLE .

    ANDAND          reduce using rule 56 (comparison -> VARIABLE signo_comp VARIABLE .)
    OROR            reduce using rule 56 (comparison -> VARIABLE signo_comp VARIABLE .)
    LLAVEIZ         reduce using rule 56 (comparison -> VARIABLE signo_comp VARIABLE .)


state 130

    (57) comparison -> VARIABLE signo_comp U8 .

    ANDAND          reduce using rule 57 (comparison -> VARIABLE signo_comp U8 .)
    OROR            reduce using rule 57 (comparison -> VARIABLE signo_comp U8 .)
    LLAVEIZ         reduce using rule 57 (comparison -> VARIABLE signo_comp U8 .)


state 131

    (58) comparison -> U8 signo_comp VARIABLE .

    ANDAND          reduce using rule 58 (comparison -> U8 signo_comp VARIABLE .)
    OROR            reduce using rule 58 (comparison -> U8 signo_comp VARIABLE .)
    LLAVEIZ         reduce using rule 58 (comparison -> U8 signo_comp VARIABLE .)


state 132

    (65) f_comparacion -> VARIABLE .

    LLAVEIZ         reduce using rule 65 (f_comparacion -> VARIABLE .)


state 133

    (66) for_loop -> FOR VARIABLE IN f_comparacion . LLAVEIZ rust LLAVEDER

    LLAVEIZ         shift and go to state 166


state 134

    (64) f_comparacion -> rango .

    LLAVEIZ         reduce using rule 64 (f_comparacion -> rango .)


state 135

    (88) rango -> U8 . DOT DOT U8

    DOT             shift and go to state 167


state 136

    (118) vector_methods -> VARIABLE empty DOT empty . PUSH_VEC LPAREN expresion RPAREN
    (119) vector_methods -> VARIABLE empty DOT empty . POP_VEC LPAREN RPAREN
    (90) slice_get -> VARIABLE empty DOT empty . GET_SLICE empty LPAREN valor_get RPAREN
    (93) slice_contains -> VARIABLE empty DOT empty . CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (46) hashset_insert -> VARIABLE empty DOT empty . INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE
    (47) hashset_union -> VARIABLE empty DOT empty . UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE

    PUSH_VEC        shift and go to state 168
    POP_VEC         shift and go to state 169
    GET_SLICE       shift and go to state 170
    CONTAINS_SLICE  shift and go to state 171
    INSERT_HASH     shift and go to state 172
    UNION_HASH      shift and go to state 173


state 137

    (74) sent_stru -> TUPLE LPAREN argumentos_tipo . RPAREN ENDLINE

    RPAREN          shift and go to state 174


state 138

    (71) argumentos_tipo -> tipos .
    (72) argumentos_tipo -> tipos . COMMA argumentos_tipo

    RPAREN          reduce using rule 71 (argumentos_tipo -> tipos .)
    COMMA           shift and go to state 175


state 139

    (120) tipos -> DATATYPES .

    COMMA           reduce using rule 120 (tipos -> DATATYPES .)
    RPAREN          reduce using rule 120 (tipos -> DATATYPES .)
    ASIGNAR         reduce using rule 120 (tipos -> DATATYPES .)
    LLAVEDER        reduce using rule 120 (tipos -> DATATYPES .)


state 140

    (121) tipos -> NUMDATATYPES .

    COMMA           reduce using rule 121 (tipos -> NUMDATATYPES .)
    RPAREN          reduce using rule 121 (tipos -> NUMDATATYPES .)
    ASIGNAR         reduce using rule 121 (tipos -> NUMDATATYPES .)
    LLAVEDER        reduce using rule 121 (tipos -> NUMDATATYPES .)


state 141

    (68) argumentos_juntos -> VARIABLE . ASIGNATION_TYPE tipos
    (69) argumentos_juntos -> VARIABLE . ASIGNATION_TYPE tipos COMMA argumentos_juntos

    ASIGNATION_TYPE shift and go to state 176


state 142

    (75) sent_stru -> VARIABLE LLAVEIZ argumentos_juntos . LLAVEDER

    LLAVEDER        shift and go to state 177


state 143

    (70) argumentos_juntos -> PUB . VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos

    VARIABLE        shift and go to state 178


state 144

    (95) while_loop -> WHILE validations LLAVEIZ rust . LLAVEDER

    LLAVEDER        shift and go to state 179


state 145

    (115) empty_vec -> ASIGNAR VECT . PATHSEP NEWFUNC ENDLINE
    (117) empty_vec -> ASIGNAR VECT . PATHSEP FROM LPAREN RPAREN ENDLINE
    (106) vector_content -> ASIGNAR VECT . PATHSEP FROM LPAREN vect_list RPAREN ENDLINE

    PATHSEP         shift and go to state 180


state 146

    (116) empty_vec -> ASIGNAR VECTMACRO . BRACKETL BRACKETR ENDLINE
    (105) vector_content -> ASIGNAR VECTMACRO . vect_list ENDLINE
    (107) vect_list -> . BRACKETL vector_elements BRACKETR

    BRACKETL        shift and go to state 181

    vect_list                      shift and go to state 182

state 147

    (104) data_vector -> declare_vector ASIGNAR VECTMACRO BRACKETL . element_type COMMA vector_elements BRACKETR ENDLINE
    (110) element_type -> . U8 empty NUMDATATYPES

    U8              shift and go to state 184

    element_type                   shift and go to state 183

state 148

    (111) types_vector -> VECT empty LESST . DATATYPES GREATER
    (112) types_vector -> VECT empty LESST . NUMDATATYPES GREATER

    DATATYPES       shift and go to state 185
    NUMDATATYPES    shift and go to state 186


state 149

    (96) read_data -> IO empty PATHSEP empty . STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE

    STDIN           shift and go to state 187


state 150

    (100) arguments -> VARIABLE . ASIGNATION_TYPE tipos
    (101) arguments -> VARIABLE . ASIGNATION_TYPE tipos COMMA arguments

    ASIGNATION_TYPE shift and go to state 188


state 151

    (98) function -> FUNCTION VARIABLE LPAREN arguments . RPAREN LLAVEIZ rust LLAVEDER

    RPAREN          shift and go to state 189


state 152

    (99) empty_function -> FUNCTION VARIABLE LPAREN RPAREN . LLAVEIZ rust LLAVEDER

    LLAVEIZ         shift and go to state 190


state 153

    (113) declare_vector -> LET MUT VARIABLE ASIGNATION_TYPE .
    (31) var_tipo -> VARIABLE ASIGNATION_TYPE . tipos
    (120) tipos -> . DATATYPES
    (121) tipos -> . NUMDATATYPES

    ASIGNAR         reduce using rule 113 (declare_vector -> LET MUT VARIABLE ASIGNATION_TYPE .)
    VECT            reduce using rule 113 (declare_vector -> LET MUT VARIABLE ASIGNATION_TYPE .)
    DATATYPES       shift and go to state 139
    NUMDATATYPES    shift and go to state 140

    tipos                          shift and go to state 154

state 154

    (31) var_tipo -> VARIABLE ASIGNATION_TYPE tipos .

    ASIGNAR         reduce using rule 31 (var_tipo -> VARIABLE ASIGNATION_TYPE tipos .)


state 155

    (43) hashset -> HASHSET empty PATHSEP . empty NEWFUNC
    (94) empty -> .

    NEWFUNC         reduce using rule 94 (empty -> .)

    empty                          shift and go to state 191

state 156

    (79) art_exp -> VARIABLE signo_arit VARIABLE .
    (79) art_exp -> VARIABLE . signo_arit VARIABLE
    (81) art_exp -> VARIABLE . signo_arit U8
    (83) signo_arit -> . MAS
    (84) signo_arit -> . MENOS
    (85) signo_arit -> . MULT
    (86) signo_arit -> . DIVISION
    (87) signo_arit -> . MODULO

    ENDLINE         reduce using rule 79 (art_exp -> VARIABLE signo_arit VARIABLE .)
    MAS             shift and go to state 117
    MENOS           shift and go to state 118
    MULT            shift and go to state 119
    DIVISION        shift and go to state 120
    MODULO          shift and go to state 121

    signo_arit                     shift and go to state 192

state 157

    (77) op_mat -> VARIABLE signo_arit art_exp .

    ENDLINE         reduce using rule 77 (op_mat -> VARIABLE signo_arit art_exp .)


state 158

    (81) art_exp -> VARIABLE signo_arit U8 .
    (80) art_exp -> U8 . signo_arit VARIABLE
    (82) art_exp -> U8 . signo_arit U8
    (83) signo_arit -> . MAS
    (84) signo_arit -> . MENOS
    (85) signo_arit -> . MULT
    (86) signo_arit -> . DIVISION
    (87) signo_arit -> . MODULO

    ENDLINE         reduce using rule 81 (art_exp -> VARIABLE signo_arit U8 .)
    MAS             shift and go to state 117
    MENOS           shift and go to state 118
    MULT            shift and go to state 119
    DIVISION        shift and go to state 120
    MODULO          shift and go to state 121

    signo_arit                     shift and go to state 193

state 159

    (82) art_exp -> U8 signo_arit U8 .
    (80) art_exp -> U8 . signo_arit VARIABLE
    (82) art_exp -> U8 . signo_arit U8
    (83) signo_arit -> . MAS
    (84) signo_arit -> . MENOS
    (85) signo_arit -> . MULT
    (86) signo_arit -> . DIVISION
    (87) signo_arit -> . MODULO

    ENDLINE         reduce using rule 82 (art_exp -> U8 signo_arit U8 .)
    MAS             shift and go to state 117
    MENOS           shift and go to state 118
    MULT            shift and go to state 119
    DIVISION        shift and go to state 120
    MODULO          shift and go to state 121

    signo_arit                     shift and go to state 193

state 160

    (78) op_mat -> U8 signo_arit art_exp .

    ENDLINE         reduce using rule 78 (op_mat -> U8 signo_arit art_exp .)


state 161

    (80) art_exp -> U8 signo_arit VARIABLE .
    (79) art_exp -> VARIABLE . signo_arit VARIABLE
    (81) art_exp -> VARIABLE . signo_arit U8
    (83) signo_arit -> . MAS
    (84) signo_arit -> . MENOS
    (85) signo_arit -> . MULT
    (86) signo_arit -> . DIVISION
    (87) signo_arit -> . MODULO

    ENDLINE         reduce using rule 80 (art_exp -> U8 signo_arit VARIABLE .)
    MAS             shift and go to state 117
    MENOS           shift and go to state 118
    MULT            shift and go to state 119
    DIVISION        shift and go to state 120
    MODULO          shift and go to state 121

    signo_arit                     shift and go to state 192

state 162

    (89) slice_exp -> AND empty VARIABLE . empty BRACKETL rango BRACKETR
    (94) empty -> .

    BRACKETL        reduce using rule 94 (empty -> .)

    empty                          shift and go to state 194

state 163

    (37) prints -> PRINTS empty LPAREN print_expresion RPAREN . empty ENDLINE
    (94) empty -> .

    ENDLINE         reduce using rule 94 (empty -> .)

    empty                          shift and go to state 195

state 164

    (39) print_expresion -> STRING COMMA . print_args
    (40) print_args -> . print_datos COMMA print_args
    (41) print_args -> . print_datos
    (42) print_datos -> . expresion
    (122) expresion -> . STRING
    (123) expresion -> . U8
    (124) expresion -> . F32
    (125) expresion -> . VARIABLE

    STRING          shift and go to state 70
    U8              shift and go to state 71
    F32             shift and go to state 72
    VARIABLE        shift and go to state 73

    print_args                     shift and go to state 196
    print_datos                    shift and go to state 197
    expresion                      shift and go to state 198

state 165

    (49) conditional -> if_type validations LLAVEIZ rust LLAVEDER .

    $end            reduce using rule 49 (conditional -> if_type validations LLAVEIZ rust LLAVEDER .)
    ENDLINE         reduce using rule 49 (conditional -> if_type validations LLAVEIZ rust LLAVEDER .)
    LLAVEDER        reduce using rule 49 (conditional -> if_type validations LLAVEIZ rust LLAVEDER .)


state 166

    (66) for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ . rust LLAVEDER
    (1) rust -> . asignacion
    (2) rust -> . asignacion_sintipo
    (3) rust -> . prints
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . while_loop
    (10) rust -> . empty_vector
    (11) rust -> . vector_methods
    (12) rust -> . data_vector
    (13) rust -> . slice_get
    (14) rust -> . slice_contains
    (15) rust -> . read_data
    (16) rust -> . function
    (17) rust -> . empty_function
    (18) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (19) asignacion -> . other_operators ENDLINE
    (20) asignacion_sintipo -> . declarador_sintipo ASIGNAR expresion_sintipo ENDLINE
    (37) prints -> . PRINTS empty LPAREN print_expresion RPAREN empty ENDLINE
    (44) hashfunc -> . hashset_insert
    (45) hashfunc -> . hashset_union
    (49) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (48) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (66) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (67) struct_s -> . STRUCT sent_stru
    (95) while_loop -> . WHILE validations LLAVEIZ rust LLAVEDER
    (102) empty_vector -> . declare_vector types_vector empty_vec
    (118) vector_methods -> . VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (119) vector_methods -> . VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
    (103) data_vector -> . declare_vector types_vector vector_content
    (104) data_vector -> . declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE
    (90) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (93) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (96) read_data -> . IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (98) function -> . FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (99) empty_function -> . FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
    (22) declarador -> . VARIABLE
    (23) declarador -> . let_asig
    (21) other_operators -> . VARIABLE oper_asig expresion
    (24) declarador_sintipo -> . VARIABLE
    (25) declarador_sintipo -> . let_asig_sintipo
    (46) hashset_insert -> . VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE
    (47) hashset_union -> . VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE
    (50) if_type -> . IF
    (51) if_type -> . ELSE IF
    (52) if_type -> . ELSE
    (113) declare_vector -> . LET MUT VARIABLE ASIGNATION_TYPE
    (114) declare_vector -> . LET VARIABLE ASIGNATION_TYPE
    (26) let_asig -> . LET var_tipo
    (27) let_asig -> . LET MUT var_tipo
    (28) let_asig_sintipo -> . LET MUT VARIABLE
    (29) let_asig_sintipo -> . LET VARIABLE

    PRINTS          shift and go to state 22
    FOR             shift and go to state 26
    STRUCT          shift and go to state 28
    WHILE           shift and go to state 29
    VARIABLE        shift and go to state 27
    IO              shift and go to state 31
    FUNCTION        shift and go to state 32
    IF              shift and go to state 35
    ELSE            shift and go to state 36
    LET             shift and go to state 37

    rust                           shift and go to state 199
    asignacion                     shift and go to state 2
    asignacion_sintipo             shift and go to state 3
    prints                         shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    while_loop                     shift and go to state 10
    empty_vector                   shift and go to state 11
    vector_methods                 shift and go to state 12
    data_vector                    shift and go to state 13
    slice_get                      shift and go to state 14
    slice_contains                 shift and go to state 15
    read_data                      shift and go to state 16
    function                       shift and go to state 17
    empty_function                 shift and go to state 18
    declarador                     shift and go to state 19
    other_operators                shift and go to state 20
    declarador_sintipo             shift and go to state 21
    hashset_insert                 shift and go to state 23
    hashset_union                  shift and go to state 24
    if_type                        shift and go to state 25
    declare_vector                 shift and go to state 30
    let_asig                       shift and go to state 33
    let_asig_sintipo               shift and go to state 34

state 167

    (88) rango -> U8 DOT . DOT U8

    DOT             shift and go to state 200


state 168

    (118) vector_methods -> VARIABLE empty DOT empty PUSH_VEC . LPAREN expresion RPAREN

    LPAREN          shift and go to state 201


state 169

    (119) vector_methods -> VARIABLE empty DOT empty POP_VEC . LPAREN RPAREN

    LPAREN          shift and go to state 202


state 170

    (90) slice_get -> VARIABLE empty DOT empty GET_SLICE . empty LPAREN valor_get RPAREN
    (94) empty -> .

    LPAREN          reduce using rule 94 (empty -> .)

    empty                          shift and go to state 203

state 171

    (93) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE . empty LPAREN AND U8 RPAREN
    (94) empty -> .

    LPAREN          reduce using rule 94 (empty -> .)

    empty                          shift and go to state 204

state 172

    (46) hashset_insert -> VARIABLE empty DOT empty INSERT_HASH . empty LPAREN expresion RPAREN empty ENDLINE
    (94) empty -> .

    LPAREN          reduce using rule 94 (empty -> .)

    empty                          shift and go to state 205

state 173

    (47) hashset_union -> VARIABLE empty DOT empty UNION_HASH . empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE
    (94) empty -> .

    LPAREN          reduce using rule 94 (empty -> .)

    empty                          shift and go to state 206

state 174

    (74) sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN . ENDLINE

    ENDLINE         shift and go to state 207


state 175

    (72) argumentos_tipo -> tipos COMMA . argumentos_tipo
    (71) argumentos_tipo -> . tipos
    (72) argumentos_tipo -> . tipos COMMA argumentos_tipo
    (120) tipos -> . DATATYPES
    (121) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 139
    NUMDATATYPES    shift and go to state 140

    tipos                          shift and go to state 138
    argumentos_tipo                shift and go to state 208

state 176

    (68) argumentos_juntos -> VARIABLE ASIGNATION_TYPE . tipos
    (69) argumentos_juntos -> VARIABLE ASIGNATION_TYPE . tipos COMMA argumentos_juntos
    (120) tipos -> . DATATYPES
    (121) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 139
    NUMDATATYPES    shift and go to state 140

    tipos                          shift and go to state 209

state 177

    (75) sent_stru -> VARIABLE LLAVEIZ argumentos_juntos LLAVEDER .

    $end            reduce using rule 75 (sent_stru -> VARIABLE LLAVEIZ argumentos_juntos LLAVEDER .)
    LLAVEDER        reduce using rule 75 (sent_stru -> VARIABLE LLAVEIZ argumentos_juntos LLAVEDER .)


state 178

    (70) argumentos_juntos -> PUB VARIABLE . ASIGNATION_TYPE tipos COMMA argumentos_juntos

    ASIGNATION_TYPE shift and go to state 210


state 179

    (95) while_loop -> WHILE validations LLAVEIZ rust LLAVEDER .

    $end            reduce using rule 95 (while_loop -> WHILE validations LLAVEIZ rust LLAVEDER .)
    LLAVEDER        reduce using rule 95 (while_loop -> WHILE validations LLAVEIZ rust LLAVEDER .)


state 180

    (115) empty_vec -> ASIGNAR VECT PATHSEP . NEWFUNC ENDLINE
    (117) empty_vec -> ASIGNAR VECT PATHSEP . FROM LPAREN RPAREN ENDLINE
    (106) vector_content -> ASIGNAR VECT PATHSEP . FROM LPAREN vect_list RPAREN ENDLINE

    NEWFUNC         shift and go to state 211
    FROM            shift and go to state 212


state 181

    (116) empty_vec -> ASIGNAR VECTMACRO BRACKETL . BRACKETR ENDLINE
    (107) vect_list -> BRACKETL . vector_elements BRACKETR
    (108) vector_elements -> . expresion
    (109) vector_elements -> . expresion COMMA vector_elements
    (122) expresion -> . STRING
    (123) expresion -> . U8
    (124) expresion -> . F32
    (125) expresion -> . VARIABLE

    BRACKETR        shift and go to state 213
    STRING          shift and go to state 70
    U8              shift and go to state 71
    F32             shift and go to state 72
    VARIABLE        shift and go to state 73

    vector_elements                shift and go to state 214
    expresion                      shift and go to state 215

state 182

    (105) vector_content -> ASIGNAR VECTMACRO vect_list . ENDLINE

    ENDLINE         shift and go to state 216


state 183

    (104) data_vector -> declare_vector ASIGNAR VECTMACRO BRACKETL element_type . COMMA vector_elements BRACKETR ENDLINE

    COMMA           shift and go to state 217


state 184

    (110) element_type -> U8 . empty NUMDATATYPES
    (94) empty -> .

    NUMDATATYPES    reduce using rule 94 (empty -> .)

    empty                          shift and go to state 218

state 185

    (111) types_vector -> VECT empty LESST DATATYPES . GREATER

    GREATER         shift and go to state 219


state 186

    (112) types_vector -> VECT empty LESST NUMDATATYPES . GREATER

    GREATER         shift and go to state 220


state 187

    (96) read_data -> IO empty PATHSEP empty STDIN . LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE

    LPAREN          shift and go to state 221


state 188

    (100) arguments -> VARIABLE ASIGNATION_TYPE . tipos
    (101) arguments -> VARIABLE ASIGNATION_TYPE . tipos COMMA arguments
    (120) tipos -> . DATATYPES
    (121) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 139
    NUMDATATYPES    shift and go to state 140

    tipos                          shift and go to state 222

state 189

    (98) function -> FUNCTION VARIABLE LPAREN arguments RPAREN . LLAVEIZ rust LLAVEDER

    LLAVEIZ         shift and go to state 223


state 190

    (99) empty_function -> FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ . rust LLAVEDER
    (1) rust -> . asignacion
    (2) rust -> . asignacion_sintipo
    (3) rust -> . prints
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . while_loop
    (10) rust -> . empty_vector
    (11) rust -> . vector_methods
    (12) rust -> . data_vector
    (13) rust -> . slice_get
    (14) rust -> . slice_contains
    (15) rust -> . read_data
    (16) rust -> . function
    (17) rust -> . empty_function
    (18) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (19) asignacion -> . other_operators ENDLINE
    (20) asignacion_sintipo -> . declarador_sintipo ASIGNAR expresion_sintipo ENDLINE
    (37) prints -> . PRINTS empty LPAREN print_expresion RPAREN empty ENDLINE
    (44) hashfunc -> . hashset_insert
    (45) hashfunc -> . hashset_union
    (49) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (48) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (66) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (67) struct_s -> . STRUCT sent_stru
    (95) while_loop -> . WHILE validations LLAVEIZ rust LLAVEDER
    (102) empty_vector -> . declare_vector types_vector empty_vec
    (118) vector_methods -> . VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (119) vector_methods -> . VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
    (103) data_vector -> . declare_vector types_vector vector_content
    (104) data_vector -> . declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE
    (90) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (93) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (96) read_data -> . IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (98) function -> . FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (99) empty_function -> . FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
    (22) declarador -> . VARIABLE
    (23) declarador -> . let_asig
    (21) other_operators -> . VARIABLE oper_asig expresion
    (24) declarador_sintipo -> . VARIABLE
    (25) declarador_sintipo -> . let_asig_sintipo
    (46) hashset_insert -> . VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE
    (47) hashset_union -> . VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE
    (50) if_type -> . IF
    (51) if_type -> . ELSE IF
    (52) if_type -> . ELSE
    (113) declare_vector -> . LET MUT VARIABLE ASIGNATION_TYPE
    (114) declare_vector -> . LET VARIABLE ASIGNATION_TYPE
    (26) let_asig -> . LET var_tipo
    (27) let_asig -> . LET MUT var_tipo
    (28) let_asig_sintipo -> . LET MUT VARIABLE
    (29) let_asig_sintipo -> . LET VARIABLE

    PRINTS          shift and go to state 22
    FOR             shift and go to state 26
    STRUCT          shift and go to state 28
    WHILE           shift and go to state 29
    VARIABLE        shift and go to state 27
    IO              shift and go to state 31
    FUNCTION        shift and go to state 32
    IF              shift and go to state 35
    ELSE            shift and go to state 36
    LET             shift and go to state 37

    rust                           shift and go to state 224
    asignacion                     shift and go to state 2
    asignacion_sintipo             shift and go to state 3
    prints                         shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    while_loop                     shift and go to state 10
    empty_vector                   shift and go to state 11
    vector_methods                 shift and go to state 12
    data_vector                    shift and go to state 13
    slice_get                      shift and go to state 14
    slice_contains                 shift and go to state 15
    read_data                      shift and go to state 16
    function                       shift and go to state 17
    empty_function                 shift and go to state 18
    declarador                     shift and go to state 19
    other_operators                shift and go to state 20
    declarador_sintipo             shift and go to state 21
    hashset_insert                 shift and go to state 23
    hashset_union                  shift and go to state 24
    if_type                        shift and go to state 25
    declare_vector                 shift and go to state 30
    let_asig                       shift and go to state 33
    let_asig_sintipo               shift and go to state 34

state 191

    (43) hashset -> HASHSET empty PATHSEP empty . NEWFUNC

    NEWFUNC         shift and go to state 225


state 192

    (79) art_exp -> VARIABLE signo_arit . VARIABLE
    (81) art_exp -> VARIABLE signo_arit . U8

    VARIABLE        shift and go to state 226
    U8              shift and go to state 227


state 193

    (80) art_exp -> U8 signo_arit . VARIABLE
    (82) art_exp -> U8 signo_arit . U8

    VARIABLE        shift and go to state 229
    U8              shift and go to state 228


state 194

    (89) slice_exp -> AND empty VARIABLE empty . BRACKETL rango BRACKETR

    BRACKETL        shift and go to state 230


state 195

    (37) prints -> PRINTS empty LPAREN print_expresion RPAREN empty . ENDLINE

    ENDLINE         shift and go to state 231


state 196

    (39) print_expresion -> STRING COMMA print_args .

    RPAREN          reduce using rule 39 (print_expresion -> STRING COMMA print_args .)


state 197

    (40) print_args -> print_datos . COMMA print_args
    (41) print_args -> print_datos .

    COMMA           shift and go to state 232
    RPAREN          reduce using rule 41 (print_args -> print_datos .)


state 198

    (42) print_datos -> expresion .

    COMMA           reduce using rule 42 (print_datos -> expresion .)
    RPAREN          reduce using rule 42 (print_datos -> expresion .)


state 199

    (66) for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust . LLAVEDER

    LLAVEDER        shift and go to state 233


state 200

    (88) rango -> U8 DOT DOT . U8

    U8              shift and go to state 234


state 201

    (118) vector_methods -> VARIABLE empty DOT empty PUSH_VEC LPAREN . expresion RPAREN
    (122) expresion -> . STRING
    (123) expresion -> . U8
    (124) expresion -> . F32
    (125) expresion -> . VARIABLE

    STRING          shift and go to state 70
    U8              shift and go to state 71
    F32             shift and go to state 72
    VARIABLE        shift and go to state 73

    expresion                      shift and go to state 235

state 202

    (119) vector_methods -> VARIABLE empty DOT empty POP_VEC LPAREN . RPAREN

    RPAREN          shift and go to state 236


state 203

    (90) slice_get -> VARIABLE empty DOT empty GET_SLICE empty . LPAREN valor_get RPAREN

    LPAREN          shift and go to state 237


state 204

    (93) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty . LPAREN AND U8 RPAREN

    LPAREN          shift and go to state 238


state 205

    (46) hashset_insert -> VARIABLE empty DOT empty INSERT_HASH empty . LPAREN expresion RPAREN empty ENDLINE

    LPAREN          shift and go to state 239


state 206

    (47) hashset_union -> VARIABLE empty DOT empty UNION_HASH empty . LPAREN AND empty VARIABLE RPAREN empty ENDLINE

    LPAREN          shift and go to state 240


state 207

    (74) sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN ENDLINE .

    $end            reduce using rule 74 (sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 74 (sent_stru -> TUPLE LPAREN argumentos_tipo RPAREN ENDLINE .)


state 208

    (72) argumentos_tipo -> tipos COMMA argumentos_tipo .

    RPAREN          reduce using rule 72 (argumentos_tipo -> tipos COMMA argumentos_tipo .)


state 209

    (68) argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos .
    (69) argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos . COMMA argumentos_juntos

    LLAVEDER        reduce using rule 68 (argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos .)
    COMMA           shift and go to state 241


state 210

    (70) argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE . tipos COMMA argumentos_juntos
    (120) tipos -> . DATATYPES
    (121) tipos -> . NUMDATATYPES

    DATATYPES       shift and go to state 139
    NUMDATATYPES    shift and go to state 140

    tipos                          shift and go to state 242

state 211

    (115) empty_vec -> ASIGNAR VECT PATHSEP NEWFUNC . ENDLINE

    ENDLINE         shift and go to state 243


state 212

    (117) empty_vec -> ASIGNAR VECT PATHSEP FROM . LPAREN RPAREN ENDLINE
    (106) vector_content -> ASIGNAR VECT PATHSEP FROM . LPAREN vect_list RPAREN ENDLINE

    LPAREN          shift and go to state 244


state 213

    (116) empty_vec -> ASIGNAR VECTMACRO BRACKETL BRACKETR . ENDLINE

    ENDLINE         shift and go to state 245


state 214

    (107) vect_list -> BRACKETL vector_elements . BRACKETR

    BRACKETR        shift and go to state 246


state 215

    (108) vector_elements -> expresion .
    (109) vector_elements -> expresion . COMMA vector_elements

    BRACKETR        reduce using rule 108 (vector_elements -> expresion .)
    COMMA           shift and go to state 247


state 216

    (105) vector_content -> ASIGNAR VECTMACRO vect_list ENDLINE .

    $end            reduce using rule 105 (vector_content -> ASIGNAR VECTMACRO vect_list ENDLINE .)
    LLAVEDER        reduce using rule 105 (vector_content -> ASIGNAR VECTMACRO vect_list ENDLINE .)


state 217

    (104) data_vector -> declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA . vector_elements BRACKETR ENDLINE
    (108) vector_elements -> . expresion
    (109) vector_elements -> . expresion COMMA vector_elements
    (122) expresion -> . STRING
    (123) expresion -> . U8
    (124) expresion -> . F32
    (125) expresion -> . VARIABLE

    STRING          shift and go to state 70
    U8              shift and go to state 71
    F32             shift and go to state 72
    VARIABLE        shift and go to state 73

    vector_elements                shift and go to state 248
    expresion                      shift and go to state 215

state 218

    (110) element_type -> U8 empty . NUMDATATYPES

    NUMDATATYPES    shift and go to state 249


state 219

    (111) types_vector -> VECT empty LESST DATATYPES GREATER .

    ASIGNAR         reduce using rule 111 (types_vector -> VECT empty LESST DATATYPES GREATER .)


state 220

    (112) types_vector -> VECT empty LESST NUMDATATYPES GREATER .

    ASIGNAR         reduce using rule 112 (types_vector -> VECT empty LESST NUMDATATYPES GREATER .)


state 221

    (96) read_data -> IO empty PATHSEP empty STDIN LPAREN . RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE

    RPAREN          shift and go to state 250


state 222

    (100) arguments -> VARIABLE ASIGNATION_TYPE tipos .
    (101) arguments -> VARIABLE ASIGNATION_TYPE tipos . COMMA arguments

    RPAREN          reduce using rule 100 (arguments -> VARIABLE ASIGNATION_TYPE tipos .)
    COMMA           shift and go to state 251


state 223

    (98) function -> FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ . rust LLAVEDER
    (1) rust -> . asignacion
    (2) rust -> . asignacion_sintipo
    (3) rust -> . prints
    (4) rust -> . hashfunc
    (5) rust -> . conditional
    (6) rust -> . conditional_asigned
    (7) rust -> . for_loop
    (8) rust -> . struct_s
    (9) rust -> . while_loop
    (10) rust -> . empty_vector
    (11) rust -> . vector_methods
    (12) rust -> . data_vector
    (13) rust -> . slice_get
    (14) rust -> . slice_contains
    (15) rust -> . read_data
    (16) rust -> . function
    (17) rust -> . empty_function
    (18) asignacion -> . declarador ASIGNAR expresion ENDLINE
    (19) asignacion -> . other_operators ENDLINE
    (20) asignacion_sintipo -> . declarador_sintipo ASIGNAR expresion_sintipo ENDLINE
    (37) prints -> . PRINTS empty LPAREN print_expresion RPAREN empty ENDLINE
    (44) hashfunc -> . hashset_insert
    (45) hashfunc -> . hashset_union
    (49) conditional -> . if_type validations LLAVEIZ rust LLAVEDER
    (48) conditional_asigned -> . declarador ASIGNAR conditional ENDLINE
    (66) for_loop -> . FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER
    (67) struct_s -> . STRUCT sent_stru
    (95) while_loop -> . WHILE validations LLAVEIZ rust LLAVEDER
    (102) empty_vector -> . declare_vector types_vector empty_vec
    (118) vector_methods -> . VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN
    (119) vector_methods -> . VARIABLE empty DOT empty POP_VEC LPAREN RPAREN
    (103) data_vector -> . declare_vector types_vector vector_content
    (104) data_vector -> . declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE
    (90) slice_get -> . VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN
    (93) slice_contains -> . VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN
    (96) read_data -> . IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (98) function -> . FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER
    (99) empty_function -> . FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER
    (22) declarador -> . VARIABLE
    (23) declarador -> . let_asig
    (21) other_operators -> . VARIABLE oper_asig expresion
    (24) declarador_sintipo -> . VARIABLE
    (25) declarador_sintipo -> . let_asig_sintipo
    (46) hashset_insert -> . VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE
    (47) hashset_union -> . VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE
    (50) if_type -> . IF
    (51) if_type -> . ELSE IF
    (52) if_type -> . ELSE
    (113) declare_vector -> . LET MUT VARIABLE ASIGNATION_TYPE
    (114) declare_vector -> . LET VARIABLE ASIGNATION_TYPE
    (26) let_asig -> . LET var_tipo
    (27) let_asig -> . LET MUT var_tipo
    (28) let_asig_sintipo -> . LET MUT VARIABLE
    (29) let_asig_sintipo -> . LET VARIABLE

    PRINTS          shift and go to state 22
    FOR             shift and go to state 26
    STRUCT          shift and go to state 28
    WHILE           shift and go to state 29
    VARIABLE        shift and go to state 27
    IO              shift and go to state 31
    FUNCTION        shift and go to state 32
    IF              shift and go to state 35
    ELSE            shift and go to state 36
    LET             shift and go to state 37

    rust                           shift and go to state 252
    asignacion                     shift and go to state 2
    asignacion_sintipo             shift and go to state 3
    prints                         shift and go to state 4
    hashfunc                       shift and go to state 5
    conditional                    shift and go to state 6
    conditional_asigned            shift and go to state 7
    for_loop                       shift and go to state 8
    struct_s                       shift and go to state 9
    while_loop                     shift and go to state 10
    empty_vector                   shift and go to state 11
    vector_methods                 shift and go to state 12
    data_vector                    shift and go to state 13
    slice_get                      shift and go to state 14
    slice_contains                 shift and go to state 15
    read_data                      shift and go to state 16
    function                       shift and go to state 17
    empty_function                 shift and go to state 18
    declarador                     shift and go to state 19
    other_operators                shift and go to state 20
    declarador_sintipo             shift and go to state 21
    hashset_insert                 shift and go to state 23
    hashset_union                  shift and go to state 24
    if_type                        shift and go to state 25
    declare_vector                 shift and go to state 30
    let_asig                       shift and go to state 33
    let_asig_sintipo               shift and go to state 34

state 224

    (99) empty_function -> FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust . LLAVEDER

    LLAVEDER        shift and go to state 253


state 225

    (43) hashset -> HASHSET empty PATHSEP empty NEWFUNC .

    ENDLINE         reduce using rule 43 (hashset -> HASHSET empty PATHSEP empty NEWFUNC .)


state 226

    (79) art_exp -> VARIABLE signo_arit VARIABLE .

    ENDLINE         reduce using rule 79 (art_exp -> VARIABLE signo_arit VARIABLE .)


state 227

    (81) art_exp -> VARIABLE signo_arit U8 .

    ENDLINE         reduce using rule 81 (art_exp -> VARIABLE signo_arit U8 .)


state 228

    (82) art_exp -> U8 signo_arit U8 .

    ENDLINE         reduce using rule 82 (art_exp -> U8 signo_arit U8 .)


state 229

    (80) art_exp -> U8 signo_arit VARIABLE .

    ENDLINE         reduce using rule 80 (art_exp -> U8 signo_arit VARIABLE .)


state 230

    (89) slice_exp -> AND empty VARIABLE empty BRACKETL . rango BRACKETR
    (88) rango -> . U8 DOT DOT U8

    U8              shift and go to state 135

    rango                          shift and go to state 254

state 231

    (37) prints -> PRINTS empty LPAREN print_expresion RPAREN empty ENDLINE .

    $end            reduce using rule 37 (prints -> PRINTS empty LPAREN print_expresion RPAREN empty ENDLINE .)
    LLAVEDER        reduce using rule 37 (prints -> PRINTS empty LPAREN print_expresion RPAREN empty ENDLINE .)


state 232

    (40) print_args -> print_datos COMMA . print_args
    (40) print_args -> . print_datos COMMA print_args
    (41) print_args -> . print_datos
    (42) print_datos -> . expresion
    (122) expresion -> . STRING
    (123) expresion -> . U8
    (124) expresion -> . F32
    (125) expresion -> . VARIABLE

    STRING          shift and go to state 70
    U8              shift and go to state 71
    F32             shift and go to state 72
    VARIABLE        shift and go to state 73

    print_datos                    shift and go to state 197
    print_args                     shift and go to state 255
    expresion                      shift and go to state 198

state 233

    (66) for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER .

    $end            reduce using rule 66 (for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER .)
    LLAVEDER        reduce using rule 66 (for_loop -> FOR VARIABLE IN f_comparacion LLAVEIZ rust LLAVEDER .)


state 234

    (88) rango -> U8 DOT DOT U8 .

    LLAVEIZ         reduce using rule 88 (rango -> U8 DOT DOT U8 .)
    BRACKETR        reduce using rule 88 (rango -> U8 DOT DOT U8 .)
    RPAREN          reduce using rule 88 (rango -> U8 DOT DOT U8 .)


state 235

    (118) vector_methods -> VARIABLE empty DOT empty PUSH_VEC LPAREN expresion . RPAREN

    RPAREN          shift and go to state 256


state 236

    (119) vector_methods -> VARIABLE empty DOT empty POP_VEC LPAREN RPAREN .

    $end            reduce using rule 119 (vector_methods -> VARIABLE empty DOT empty POP_VEC LPAREN RPAREN .)
    LLAVEDER        reduce using rule 119 (vector_methods -> VARIABLE empty DOT empty POP_VEC LPAREN RPAREN .)


state 237

    (90) slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN . valor_get RPAREN
    (91) valor_get -> . rango
    (92) valor_get -> . U8
    (88) rango -> . U8 DOT DOT U8

    U8              shift and go to state 259

    valor_get                      shift and go to state 257
    rango                          shift and go to state 258

state 238

    (93) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN . AND U8 RPAREN

    AND             shift and go to state 260


state 239

    (46) hashset_insert -> VARIABLE empty DOT empty INSERT_HASH empty LPAREN . expresion RPAREN empty ENDLINE
    (122) expresion -> . STRING
    (123) expresion -> . U8
    (124) expresion -> . F32
    (125) expresion -> . VARIABLE

    STRING          shift and go to state 70
    U8              shift and go to state 71
    F32             shift and go to state 72
    VARIABLE        shift and go to state 73

    expresion                      shift and go to state 261

state 240

    (47) hashset_union -> VARIABLE empty DOT empty UNION_HASH empty LPAREN . AND empty VARIABLE RPAREN empty ENDLINE

    AND             shift and go to state 262


state 241

    (69) argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos COMMA . argumentos_juntos
    (68) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos
    (69) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
    (70) argumentos_juntos -> . PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos

    VARIABLE        shift and go to state 141
    PUB             shift and go to state 143

    argumentos_juntos              shift and go to state 263

state 242

    (70) argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos . COMMA argumentos_juntos

    COMMA           shift and go to state 264


state 243

    (115) empty_vec -> ASIGNAR VECT PATHSEP NEWFUNC ENDLINE .

    $end            reduce using rule 115 (empty_vec -> ASIGNAR VECT PATHSEP NEWFUNC ENDLINE .)
    LLAVEDER        reduce using rule 115 (empty_vec -> ASIGNAR VECT PATHSEP NEWFUNC ENDLINE .)


state 244

    (117) empty_vec -> ASIGNAR VECT PATHSEP FROM LPAREN . RPAREN ENDLINE
    (106) vector_content -> ASIGNAR VECT PATHSEP FROM LPAREN . vect_list RPAREN ENDLINE
    (107) vect_list -> . BRACKETL vector_elements BRACKETR

    RPAREN          shift and go to state 265
    BRACKETL        shift and go to state 267

    vect_list                      shift and go to state 266

state 245

    (116) empty_vec -> ASIGNAR VECTMACRO BRACKETL BRACKETR ENDLINE .

    $end            reduce using rule 116 (empty_vec -> ASIGNAR VECTMACRO BRACKETL BRACKETR ENDLINE .)
    LLAVEDER        reduce using rule 116 (empty_vec -> ASIGNAR VECTMACRO BRACKETL BRACKETR ENDLINE .)


state 246

    (107) vect_list -> BRACKETL vector_elements BRACKETR .

    ENDLINE         reduce using rule 107 (vect_list -> BRACKETL vector_elements BRACKETR .)
    RPAREN          reduce using rule 107 (vect_list -> BRACKETL vector_elements BRACKETR .)


state 247

    (109) vector_elements -> expresion COMMA . vector_elements
    (108) vector_elements -> . expresion
    (109) vector_elements -> . expresion COMMA vector_elements
    (122) expresion -> . STRING
    (123) expresion -> . U8
    (124) expresion -> . F32
    (125) expresion -> . VARIABLE

    STRING          shift and go to state 70
    U8              shift and go to state 71
    F32             shift and go to state 72
    VARIABLE        shift and go to state 73

    expresion                      shift and go to state 215
    vector_elements                shift and go to state 268

state 248

    (104) data_vector -> declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements . BRACKETR ENDLINE

    BRACKETR        shift and go to state 269


state 249

    (110) element_type -> U8 empty NUMDATATYPES .

    COMMA           reduce using rule 110 (element_type -> U8 empty NUMDATATYPES .)


state 250

    (96) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN . empty DOT empty READ LPAREN reference RPAREN ENDLINE
    (94) empty -> .

    DOT             reduce using rule 94 (empty -> .)

    empty                          shift and go to state 270

state 251

    (101) arguments -> VARIABLE ASIGNATION_TYPE tipos COMMA . arguments
    (100) arguments -> . VARIABLE ASIGNATION_TYPE tipos
    (101) arguments -> . VARIABLE ASIGNATION_TYPE tipos COMMA arguments

    VARIABLE        shift and go to state 150

    arguments                      shift and go to state 271

state 252

    (98) function -> FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust . LLAVEDER

    LLAVEDER        shift and go to state 272


state 253

    (99) empty_function -> FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER .

    $end            reduce using rule 99 (empty_function -> FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER .)
    LLAVEDER        reduce using rule 99 (empty_function -> FUNCTION VARIABLE LPAREN RPAREN LLAVEIZ rust LLAVEDER .)


state 254

    (89) slice_exp -> AND empty VARIABLE empty BRACKETL rango . BRACKETR

    BRACKETR        shift and go to state 273


state 255

    (40) print_args -> print_datos COMMA print_args .

    RPAREN          reduce using rule 40 (print_args -> print_datos COMMA print_args .)


state 256

    (118) vector_methods -> VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN .

    $end            reduce using rule 118 (vector_methods -> VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN .)
    LLAVEDER        reduce using rule 118 (vector_methods -> VARIABLE empty DOT empty PUSH_VEC LPAREN expresion RPAREN .)


state 257

    (90) slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get . RPAREN

    RPAREN          shift and go to state 274


state 258

    (91) valor_get -> rango .

    RPAREN          reduce using rule 91 (valor_get -> rango .)


state 259

    (92) valor_get -> U8 .
    (88) rango -> U8 . DOT DOT U8

    RPAREN          reduce using rule 92 (valor_get -> U8 .)
    DOT             shift and go to state 167


state 260

    (93) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND . U8 RPAREN

    U8              shift and go to state 275


state 261

    (46) hashset_insert -> VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion . RPAREN empty ENDLINE

    RPAREN          shift and go to state 276


state 262

    (47) hashset_union -> VARIABLE empty DOT empty UNION_HASH empty LPAREN AND . empty VARIABLE RPAREN empty ENDLINE
    (94) empty -> .

    VARIABLE        reduce using rule 94 (empty -> .)

    empty                          shift and go to state 277

state 263

    (69) argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos .

    LLAVEDER        reduce using rule 69 (argumentos_juntos -> VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos .)


state 264

    (70) argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos COMMA . argumentos_juntos
    (68) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos
    (69) argumentos_juntos -> . VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos
    (70) argumentos_juntos -> . PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos

    VARIABLE        shift and go to state 141
    PUB             shift and go to state 143

    argumentos_juntos              shift and go to state 278

state 265

    (117) empty_vec -> ASIGNAR VECT PATHSEP FROM LPAREN RPAREN . ENDLINE

    ENDLINE         shift and go to state 279


state 266

    (106) vector_content -> ASIGNAR VECT PATHSEP FROM LPAREN vect_list . RPAREN ENDLINE

    RPAREN          shift and go to state 280


state 267

    (107) vect_list -> BRACKETL . vector_elements BRACKETR
    (108) vector_elements -> . expresion
    (109) vector_elements -> . expresion COMMA vector_elements
    (122) expresion -> . STRING
    (123) expresion -> . U8
    (124) expresion -> . F32
    (125) expresion -> . VARIABLE

    STRING          shift and go to state 70
    U8              shift and go to state 71
    F32             shift and go to state 72
    VARIABLE        shift and go to state 73

    vector_elements                shift and go to state 214
    expresion                      shift and go to state 215

state 268

    (109) vector_elements -> expresion COMMA vector_elements .

    BRACKETR        reduce using rule 109 (vector_elements -> expresion COMMA vector_elements .)


state 269

    (104) data_vector -> declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR . ENDLINE

    ENDLINE         shift and go to state 281


state 270

    (96) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty . DOT empty READ LPAREN reference RPAREN ENDLINE

    DOT             shift and go to state 282


state 271

    (101) arguments -> VARIABLE ASIGNATION_TYPE tipos COMMA arguments .

    RPAREN          reduce using rule 101 (arguments -> VARIABLE ASIGNATION_TYPE tipos COMMA arguments .)


state 272

    (98) function -> FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER .

    $end            reduce using rule 98 (function -> FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER .)
    LLAVEDER        reduce using rule 98 (function -> FUNCTION VARIABLE LPAREN arguments RPAREN LLAVEIZ rust LLAVEDER .)


state 273

    (89) slice_exp -> AND empty VARIABLE empty BRACKETL rango BRACKETR .

    ENDLINE         reduce using rule 89 (slice_exp -> AND empty VARIABLE empty BRACKETL rango BRACKETR .)


state 274

    (90) slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN .

    $end            reduce using rule 90 (slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN .)
    LLAVEDER        reduce using rule 90 (slice_get -> VARIABLE empty DOT empty GET_SLICE empty LPAREN valor_get RPAREN .)


state 275

    (93) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 . RPAREN

    RPAREN          shift and go to state 283


state 276

    (46) hashset_insert -> VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN . empty ENDLINE
    (94) empty -> .

    ENDLINE         reduce using rule 94 (empty -> .)

    empty                          shift and go to state 284

state 277

    (47) hashset_union -> VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty . VARIABLE RPAREN empty ENDLINE

    VARIABLE        shift and go to state 285


state 278

    (70) argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos .

    LLAVEDER        reduce using rule 70 (argumentos_juntos -> PUB VARIABLE ASIGNATION_TYPE tipos COMMA argumentos_juntos .)


state 279

    (117) empty_vec -> ASIGNAR VECT PATHSEP FROM LPAREN RPAREN ENDLINE .

    $end            reduce using rule 117 (empty_vec -> ASIGNAR VECT PATHSEP FROM LPAREN RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 117 (empty_vec -> ASIGNAR VECT PATHSEP FROM LPAREN RPAREN ENDLINE .)


state 280

    (106) vector_content -> ASIGNAR VECT PATHSEP FROM LPAREN vect_list RPAREN . ENDLINE

    ENDLINE         shift and go to state 286


state 281

    (104) data_vector -> declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE .

    $end            reduce using rule 104 (data_vector -> declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE .)
    LLAVEDER        reduce using rule 104 (data_vector -> declare_vector ASIGNAR VECTMACRO BRACKETL element_type COMMA vector_elements BRACKETR ENDLINE .)


state 282

    (96) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT . empty READ LPAREN reference RPAREN ENDLINE
    (94) empty -> .

    READ            reduce using rule 94 (empty -> .)

    empty                          shift and go to state 287

state 283

    (93) slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN .

    $end            reduce using rule 93 (slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN .)
    LLAVEDER        reduce using rule 93 (slice_contains -> VARIABLE empty DOT empty CONTAINS_SLICE empty LPAREN AND U8 RPAREN .)


state 284

    (46) hashset_insert -> VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty . ENDLINE

    ENDLINE         shift and go to state 288


state 285

    (47) hashset_union -> VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE . RPAREN empty ENDLINE

    RPAREN          shift and go to state 289


state 286

    (106) vector_content -> ASIGNAR VECT PATHSEP FROM LPAREN vect_list RPAREN ENDLINE .

    $end            reduce using rule 106 (vector_content -> ASIGNAR VECT PATHSEP FROM LPAREN vect_list RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 106 (vector_content -> ASIGNAR VECT PATHSEP FROM LPAREN vect_list RPAREN ENDLINE .)


state 287

    (96) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty . READ LPAREN reference RPAREN ENDLINE

    READ            shift and go to state 290


state 288

    (46) hashset_insert -> VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE .

    $end            reduce using rule 46 (hashset_insert -> VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE .)
    LLAVEDER        reduce using rule 46 (hashset_insert -> VARIABLE empty DOT empty INSERT_HASH empty LPAREN expresion RPAREN empty ENDLINE .)


state 289

    (47) hashset_union -> VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN . empty ENDLINE
    (94) empty -> .

    ENDLINE         reduce using rule 94 (empty -> .)

    empty                          shift and go to state 291

state 290

    (96) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ . LPAREN reference RPAREN ENDLINE

    LPAREN          shift and go to state 292


state 291

    (47) hashset_union -> VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty . ENDLINE

    ENDLINE         shift and go to state 293


state 292

    (96) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN . reference RPAREN ENDLINE
    (97) reference -> . AND empty MUT VARIABLE

    AND             shift and go to state 295

    reference                      shift and go to state 294

state 293

    (47) hashset_union -> VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE .

    $end            reduce using rule 47 (hashset_union -> VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE .)
    LLAVEDER        reduce using rule 47 (hashset_union -> VARIABLE empty DOT empty UNION_HASH empty LPAREN AND empty VARIABLE RPAREN empty ENDLINE .)


state 294

    (96) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference . RPAREN ENDLINE

    RPAREN          shift and go to state 296


state 295

    (97) reference -> AND . empty MUT VARIABLE
    (94) empty -> .

    MUT             reduce using rule 94 (empty -> .)

    empty                          shift and go to state 297

state 296

    (96) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN . ENDLINE

    ENDLINE         shift and go to state 298


state 297

    (97) reference -> AND empty . MUT VARIABLE

    MUT             shift and go to state 299


state 298

    (96) read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE .

    $end            reduce using rule 96 (read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE .)
    LLAVEDER        reduce using rule 96 (read_data -> IO empty PATHSEP empty STDIN LPAREN RPAREN empty DOT empty READ LPAREN reference RPAREN ENDLINE .)


state 299

    (97) reference -> AND empty MUT . VARIABLE

    VARIABLE        shift and go to state 300


state 300

    (97) reference -> AND empty MUT VARIABLE .

    RPAREN          reduce using rule 97 (reference -> AND empty MUT VARIABLE .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ASIGNAR in state 27 resolved as shift
WARNING: reduce/reduce conflict in state 27 resolved using rule (declarador -> VARIABLE)
WARNING: rejected rule (declarador_sintipo -> VARIABLE) in state 27
WARNING: reduce/reduce conflict in state 66 resolved using rule (let_asig_sintipo -> LET VARIABLE)
WARNING: rejected rule (var_tipo -> VARIABLE) in state 66
WARNING: reduce/reduce conflict in state 109 resolved using rule (let_asig_sintipo -> LET MUT VARIABLE)
WARNING: rejected rule (var_tipo -> VARIABLE) in state 109
WARNING: Rule (declarador_sintipo -> VARIABLE) is never reduced
WARNING: Rule (var_tipo -> VARIABLE) is never reduced
